{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>ActivityPub for Python is a set of libraries for implementing the ActivityPub protocol in Python. This facilitates the development of distributed social network applications.</p>"},{"location":"#libraries","title":"Libraries","text":""},{"location":"#apkit","title":"apkit","text":"<p><code>apkit</code> is a toolkit that makes it easier to create implementations using apsig, and apmodel.</p>"},{"location":"#features","title":"features","text":"<ul> <li>Integration with popular web frameworks (e.g. Starlette/FastAPI)</li> </ul>"},{"location":"#apsig","title":"apsig","text":"<p>The <code>apsig</code> is a set of signatures commonly used among ActivityPub implementations.</p> <p>RsaSignature2017 was ported from Takah\u0113.</p>"},{"location":"#features_1","title":"features","text":"<ul> <li>FEP-8b32 Support</li> <li>draft-cavage-http-signatures-12 Support</li> <li>RsaSignature2017 Support</li> <li>RFC9421 (in the future)</li> </ul>"},{"location":"#apmodel","title":"apmodel","text":"<p>apmodel is a set of model implementations often used in nodeinfo 2.0/2.1 and ActivityStreams 2.0 and ActivityPub.</p>"},{"location":"#features_2","title":"features","text":"<ul> <li>nodeinfo support</li> <li>Automatically convert json to a suitable model</li> </ul>"},{"location":"apmodel/","title":"Welcome to apmodel documentation!","text":"<p>apmodel is an implementation of the model commonly used among nodeinfo/ActivityStreams 2.0 and ActivityPub implementations.</p>"},{"location":"apmodel/#feature","title":"feature","text":"<ul> <li>nodeinfo support</li> <li>Automatically convert json to a suitable model</li> </ul>"},{"location":"apsig/","title":"Index","text":"<p>Document is now rewritting!</p> <p>The apsig documentation is currently being rewritten. Some formatting may differ.</p>"},{"location":"apsig/#installation","title":"Installation","text":"&gt; pip install apsig"},{"location":"apsig/draft/","title":"<code>apsig.draft</code>","text":"<p>draft-cavage-http-signatures-12\u306b\u6e96\u62e0\u3057\u305fHTTP\u7f72\u540d\u306e\u5b9f\u88c5\u3002</p>"},{"location":"apsig/draft/#apsigdraftverifier","title":"<code>apsig.draft.Verifier</code>","text":"<p>HTTP\u7f72\u540d\u3092\u691c\u8a3c\u3059\u308b\u305f\u3081\u306e\u30af\u30e9\u30b9\u3002</p> <p><code>apsig.draft</code>\u304b\u3089\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3067\u304d\u307e\u3059:  <pre><code>from apsig.draft import Verifier\n</code></pre></p>"},{"location":"apsig/draft/#_1","title":"\u4f8b","text":"<pre><code>import json\n\nfrom apsig.draft import Verifier\n\npublic_key = \"\"\"\n-----BEGIN PUBLIC KEY-----\n... (RSA PublicKey Here)\n-----END PUBLIC KEY-----\n\"\"\" # or cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey\n\n# HTTP Request Details (Here we use dummy, actually copying this code will not work)\nmethod = \"POST\"\nurl = \"https://example.com/api\"\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Date\": \"Wed, 21 Oct 2015 07:28:00 GMT\",\n    \"signature\": 'keyId=\"my-key-id\",algorithm=\"rsa-sha256\",headers=\"(request-target) Content-Type Date\",signature=\"...\"',\n    \"digest\": \"SHA-256=...\",\n}\nbody = {\"key\": \"value\"}\nverifier = Verifier(public_key, method, url, headers, body)\n</code></pre> <p>Warning</p> <p><code>body</code>\u306f<code>bytes</code>\u5f62\u5f0f\u3082\u8a31\u5bb9\u3057\u307e\u3059\u304c\u3001\u691c\u8a3c\u304c\u5931\u6557\u3059\u308b\u53ef\u80fd\u6027\u304c\u3042\u308b\u305f\u3081\u8f9e\u66f8\u578b\u306e\u5834\u5408\u306f\u305d\u306e\u307e\u307e<code>dict</code>\u3068\u3057\u3066\u6e21\u3059\u3079\u304d\u3067\u3059\u3002</p> parameter type description <code>public_pem</code> <code>str</code> Public key in PEM format or <code>cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey</code> format used to verify signatures. <code>method</code> <code>str</code> The HTTP method (e.g., <code>GET</code>, <code>POST</code>). <code>url</code> <code>str</code> The URL of the request. <code>headers</code> <code>dict</code> A dictionary of HTTP headers, including the signature and other relevant information. <code>body</code> <code>bytes</code> or <code>dict</code> The request body. Defaults to an empty byte string."},{"location":"apsig/draft/#apsigdraftverifierverify","title":"<code>apsig.draft.Verifier.verify</code>","text":"<p>\u7f72\u540d\u3092\u691c\u8a3c\u3057\u307e\u3059\u3002</p> parameter type description <code>raise_on_fail</code> <code>bool</code> Whether to return an error on verification failure. Default is False."},{"location":"apsig/draft/#_2","title":"\u4f8b","text":"<pre><code>...\nverifier = Verifier(public_key, method, url, headers, body)\nresult = verifier.verify()\n\nprint(result) # keyId or None (failed)\n</code></pre>"},{"location":"apsig/draft/#_3","title":"\u30a8\u30e9\u30fc","text":"<p>The following will only occur if the <code>raise_on_fail</code> argument is passed as <code>True</code> when calling <code>Verifier.verify</code>:</p> <ul> <li>apsig.exceptions.MissingSignature: Occurs when the Signature header is not present in the signed text.</li> <li>apsig.exceptions.UnknownSignature: Occurs when signed using an unsupported algorithm.</li> <li>apsig.exceptions.VerificationFailed: This occurs when the signature is invalid, the Digest does not match, the Date header value is more than a certain amount of time past the current time, etc.</li> </ul>"},{"location":"apsig/ldsignature/","title":"<code>apsig.LDSignature</code>","text":""},{"location":"apsig/ldsignature/#overview","title":"Overview","text":"<p>The <code>LDSignature</code> class provides methods for signing and verifying Linked Data signatures 1.0 using RSA keys. It utilizes the W3C's security vocabulary and JSON-LD normalization to ensure the integrity and authenticity of the signed documents.</p>"},{"location":"apsig/ldsignature/#methods","title":"Methods","text":""},{"location":"apsig/ldsignature/#__init__self","title":"<code>__init__(self)</code>","text":"<p>Initializes an instance of the <code>LDSignature</code> class.</p>"},{"location":"apsig/ldsignature/#signself-doc-dict-creator-str-private_key-rsarsaprivatekey-options-dict-none-created-datetimedatetime-none-dict","title":"<code>sign(self, doc: dict, creator: str, private_key: rsa.RSAPrivateKey, options: dict = None, created: datetime.datetime = None) -&gt; dict</code>","text":"<p>Signs the provided document using the specified RSA private key.</p> <p>Args: - <code>doc</code> (dict): The document to be signed. - <code>creator</code> (str): The identifier of the creator of the document. - <code>private_key</code> (rsa.RSAPrivateKey): The RSA private key used for signing. - <code>options</code> (dict, optional): Additional signing options. Defaults to None. - <code>created</code> (datetime.datetime, optional): The timestamp when the signature is created. Defaults to the current UTC time if not provided.</p> <p>Returns: - <code>dict</code>: The signed document containing the original data and the signature.</p>"},{"location":"apsig/ldsignature/#verifyself-doc-dict-public_key-rsarsapublickey-str-bool","title":"<code>verify(self, doc: dict, public_key: rsa.RSAPublicKey | str) -&gt; bool</code>","text":"<p>Verifies the signature of the provided document against the given public key.</p> <p>Args: - <code>doc</code> (dict): The signed document to verify. - <code>public_key</code> (rsa.RSAPublicKey | str): The RSA public key in PEM format or as a multibase-encoded string. - <code>raise_on_fail</code> (bool): Whether to return an error on verification failure. Default is False.</p> <p>Returns: - <code>string</code> or <code>None</code>: On success, the keyId of the creator is returned; on failure, None is returned.</p> <p>Raises: The following will only occur if the <code>raise_on_fail</code> argument is passed as <code>True</code> when calling <code>LDSignature.verify</code>:</p> <ul> <li><code>MissingSignature</code>: If the signature section is missing in the document.</li> <li><code>UnknownSignature</code>: If the signature type is not recognized.</li> <li><code>VerificationFailed</code>: If the signature verification fails.</li> </ul>"},{"location":"apsig/ldsignature/#example-usage","title":"Example Usage","text":"<pre><code>from apsig import LDSignature\nfrom cryptography.hazmat.primitives.asymmetric import rsa\n\nprivate_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\npublic_key = private_key.public_key()\n\n\n# Example document\ndocument = {\n    \"actor\": \"http://example.com/alice\",\n    \"signature\": {}\n}\n\n# Generate the signature\nld_signature = LDSignature()\nsigned_document = ld_signature.sign(document, \"http://example.com/alice\", private_key)\nprint(\"Generated Document with Signature:\")\nprint(json.dumps(signed_document, indent=2))\n\n# Verify the signature\nresult = ld_signature.verify(signed_document, public_key)\nprint(\"Is the signature valid?\", False if result is None else True)\n</code></pre>"},{"location":"apsig/ldsignature/#notes","title":"Notes","text":"<ul> <li>The <code>LDSignature</code> class assumes the usage of RSA keys and follows the signature format defined by the W3C.</li> </ul>"},{"location":"apsig/ldsignature/#exceptions","title":"Exceptions","text":"<p>The following will only occur if the <code>raise_on_fail</code> argument is passed as <code>True</code> when calling <code>LDSignature.verify</code>:</p> <ul> <li>MissingSignature: Raised when the signature section is not found in the document.</li> <li>UnknownSignature: Raised when the signature type is not recognized.</li> <li>VerificationFailed: Raised when the signature verification fails due to an invalid signature.</li> </ul>"},{"location":"apsig/proof/","title":"<code>apsig.proof</code>","text":""},{"location":"apsig/proof/#overview","title":"Overview","text":"<p>The <code>ProofSigner</code> and <code>ProofVerifier</code> classes implement the functionality for creating and verifying Object Integrity Proofs as described in FEP-8b32.</p>"},{"location":"apsig/proof/#class-proofsigner","title":"Class: <code>ProofSigner</code>","text":"<p><code>apsig</code>\u304b\u3089\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3067\u304d\u307e\u3059:  <pre><code>from apsig import ProofSigner\n</code></pre></p>"},{"location":"apsig/proof/#initialization","title":"Initialization","text":""},{"location":"apsig/proof/#__init__self-private_key-ed25519ed25519privatekey-str","title":"<code>__init__(self, private_key: ed25519.Ed25519PrivateKey | str)</code>","text":"<p>Initializes the <code>ProofSigner</code> with a private key, which can be provided either as an Ed25519 private key object or as a multibase-encoded string.</p> <p>Args: - <code>private_key</code> (ed25519.Ed25519PrivateKey | str): The Ed25519 private key as an object or a multibase-encoded string.</p> <p>Raises: - <code>TypeError</code>: If the provided private key is not of type Ed25519.</p>"},{"location":"apsig/proof/#methods","title":"Methods","text":""},{"location":"apsig/proof/#sign_dataself-hash_data-bytes-bytes","title":"<code>sign_data(self, hash_data: bytes) -&gt; bytes</code>","text":"<p>Signs the provided hash data using the private key.</p> <p>Args: - <code>hash_data</code> (bytes): The data to be signed.</p> <p>Returns: - <code>bytes</code>: The generated signature.</p>"},{"location":"apsig/proof/#canonicalizeself-document-dict-str","title":"<code>canonicalize(self, document: dict) -&gt; str</code>","text":"<p>Canonicalizes the provided document using JSON Canonicalization Scheme (JCS).</p> <p>Args: - <code>document</code> (dict): The document to be canonicalized.</p> <p>Returns: - <code>str</code>: The canonicalized representation of the document.</p>"},{"location":"apsig/proof/#transformself-unsecured_document-dict-options-dict-str","title":"<code>transform(self, unsecured_document: dict, options: dict) -&gt; str</code>","text":"<p>Transforms the unsecured document based on the provided options.</p> <p>Args: - <code>unsecured_document</code> (dict): The document that needs to be transformed. - <code>options</code> (dict): Options that dictate the transformation process.</p> <p>Returns: - <code>str</code>: The transformed document.</p> <p>Raises: - <code>ValueError</code>: If the options do not specify the correct type or cryptosuite.</p>"},{"location":"apsig/proof/#hashingself-transformed_document-str-canonical_proof_config-str-bytes","title":"<code>hashing(self, transformed_document: str, canonical_proof_config: str) -&gt; bytes</code>","text":"<p>Generates a hash for the transformed document and the canonical proof configuration.</p> <p>Args: - <code>transformed_document</code> (str): The transformed document. - <code>canonical_proof_config</code> (str): The canonical proof configuration.</p> <p>Returns: - <code>bytes</code>: The concatenated hash of both the transformed document and the proof configuration.</p>"},{"location":"apsig/proof/#create_proofself-unsecured_document-dict-options-dict-dict","title":"<code>create_proof(self, unsecured_document: dict, options: dict) -&gt; dict</code>","text":"<p>Creates a proof for the unsecured document using the specified options.</p> <p>Args: - <code>unsecured_document</code> (dict): The document for which the proof is created. - <code>options</code> (dict): Options that define how the proof is structured.</p> <p>Returns: - <code>dict</code>: The proof object containing the proof value and other relevant information.</p>"},{"location":"apsig/proof/#signself-unsecured_document-dict-options-dict-dict","title":"<code>sign(self, unsecured_document: dict, options: dict) -&gt; dict</code>","text":"<p>Signs the unsecured document by creating a proof and returning the signed document.</p> <p>Args: - <code>unsecured_document</code> (dict): The document to be signed. - <code>options</code> (dict): Options that define the signing process.</p> <p>Returns: - <code>dict</code>: The signed document, including the proof.</p>"},{"location":"apsig/proof/#example-usage","title":"Example Usage","text":"<pre><code>from apsig import ProofSigner\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\n\nprivate_key = ed25519.Ed25519PrivateKey.generate()\npublic_key = private_key.public_key()\n\n# Create a ProofSigner instance with a private key\nproof_signer = ProofSigner(private_key)\n\n# Example unsecured document\nunsecured_document = {\n    \"data\": \"This is a sample document.\"\n}\n\n# Options for the proof\noptions = {\n    \"type\": \"DataIntegrityProof\",\n    \"cryptosuite\": \"eddsa-jcs-2022\",\n}\n\n# Sign the unsecured document\nsigned_document = proof_signer.sign(unsecured_document, options)\nprint(\"Signed Document with Proof:\")\nprint(signed_document)\n</code></pre>"},{"location":"apsig/proof/#notes","title":"Notes","text":"<ul> <li>apsig only supports the use of ed25519 private keys for signing.</li> </ul>"},{"location":"apsig/proof/#exceptions","title":"Exceptions","text":"<ul> <li>TypeError: Raised when the provided private key is not of type Ed25519.</li> <li>ValueError: Raised when the provided options for transformation are invalid.</li> </ul>"},{"location":"apsig/proof/#class-proofverifier","title":"Class: <code>ProofVerifier</code>","text":"<p><code>apsig</code>\u304b\u3089\u76f4\u63a5\u30a4\u30f3\u30dd\u30fc\u30c8\u3067\u304d\u307e\u3059:  <pre><code>from apsig import ProofVerifier\n</code></pre></p>"},{"location":"apsig/proof/#initialization_1","title":"Initialization","text":""},{"location":"apsig/proof/#__init__self-public_key-ed25519ed25519publickey-str","title":"<code>__init__(self, public_key: ed25519.Ed25519PublicKey | str)</code>","text":"<p>Initializes the <code>ProofVerifier</code> with a public key, which can be provided either as an Ed25519 public key object or as a multibase-encoded string.</p> <p>Args: - <code>public_key</code> (ed25519.Ed25519PublicKey | str): The Ed25519 public key as an object or a multibase-encoded string.</p> <p>Raises: - <code>TypeError</code>: If the provided public key is not of type Ed25519.</p>"},{"location":"apsig/proof/#methods_1","title":"Methods","text":""},{"location":"apsig/proof/#verify_signatureself-signature-bytes-hash_data-bytes-none","title":"<code>verify_signature(self, signature: bytes, hash_data: bytes) -&gt; None</code>","text":"<p>Verifies the provided signature against the given hash data using the public key.</p> <p>Args: - <code>signature</code> (bytes): The signature to be verified. - <code>hash_data</code> (bytes): The hashed data to verify against.</p>"},{"location":"apsig/proof/#canonicalizeself-document-dict-str_1","title":"<code>canonicalize(self, document: dict) -&gt; str</code>","text":"<p>Canonicalizes the provided document using JSON Canonicalization Scheme (JCS).</p> <p>Args: - <code>document</code> (dict): The document to be canonicalized.</p> <p>Returns: - <code>str</code>: The canonicalized representation of the document.</p>"},{"location":"apsig/proof/#transformself-unsecured_document-dict-options-dict-str_1","title":"<code>transform(self, unsecured_document: dict, options: dict) -&gt; str</code>","text":"<p>Transforms the unsecured document based on the provided options.</p> <p>Args: - <code>unsecured_document</code> (dict): The document that needs to be transformed. - <code>options</code> (dict): Options that dictate the transformation process.</p> <p>Returns: - <code>str</code>: The transformed document.</p> <p>Raises: - <code>ValueError</code>: If the options do not specify the correct type or cryptosuite.</p>"},{"location":"apsig/proof/#hashingself-transformed_document-str-canonical_proof_config-str-bytes_1","title":"<code>hashing(self, transformed_document: str, canonical_proof_config: str) -&gt; bytes</code>","text":"<p>Generates a hash for the transformed document and the canonical proof configuration.</p> <p>Args: - <code>transformed_document</code> (str): The transformed document. - <code>canonical_proof_config</code> (str): The canonical proof configuration.</p> <p>Returns: - <code>bytes</code>: The concatenated hash of both the transformed document and the proof configuration.</p>"},{"location":"apsig/proof/#verify_proofself-secured_document-dict-dict","title":"<code>verify_proof(self, secured_document: dict) -&gt; dict</code>","text":"<p>Verifies the proof contained in the secured document.</p> <p>Args: - <code>secured_document</code> (dict): The document containing the proof to be verified.</p> <p>Returns: - <code>dict</code>: A dictionary containing:   - <code>bool</code>: <code>verified</code>: Indicates whether the proof verification was successful.   - <code>dict</code>: <code>verifiedDocument</code>: The unsecured document if verification was successful, otherwise <code>None</code>.</p> <p>Raises: - <code>ValueError</code>: If the proof is not found in the document.</p>"},{"location":"apsig/proof/#verifyself-secured_document-dict-dict","title":"<code>verify(self, secured_document: dict) -&gt; dict</code>","text":"<p>An alias for the <code>verify_proof</code> method.</p> <p>Args: - <code>secured_document</code> (dict): The document containing the proof to be verified. - <code>raise_on_fail</code> (bool): Whether to return an error on verification failure. Default is False.</p> <p>Returns: - <code>dict</code>: The result of the proof verification.</p>"},{"location":"apsig/proof/#example-usage_1","title":"Example Usage","text":"<pre><code>from apsig import ProofSigner\nfrom cryptography.hazmat.primitives.asymmetric import ed25519\n\nproof_signer = ProofVerifier(public_key)\n\nsecured_document = {\n    \"data\": \"This is a sample document.\",\n    \"proof\": {\n        \"proofValue\": \"base58btc_encoded_signature\",\n        \"type\": \"DataIntegrityProof\",\n        \"cryptosuite\": \"eddsa-jcs-2022\",\n    }\n} # not working this (invalid proofValue)\n\n# Verify the proof\nverification_result = proof_verifier.verify(secured_document)\nprint(\"Verification Result:\", verification_result) # If this code is executed as is, it is expected to return None (failure).\n</code></pre>"},{"location":"apsig/proof/#exceptions_1","title":"Exceptions","text":"<ul> <li>TypeError: Raised when the provided public key is not of type Ed25519.</li> </ul> <p>The following will only occur if the <code>raise_on_fail</code> argument is passed as <code>True</code> when calling <code>ProofVerifier.verify</code>:</p> <ul> <li>ValueError: Raised when the proof is not found or when the options for transformation are invalid.</li> <li>apsig.exceptions.UnknownSignature: Occurs when an invalid signature is passed.</li> <li>apsig.exceptions.VerificationFailed: Returned when verification fails due to internal errors, etc.</li> </ul>"},{"location":"references/apkit/","title":"apkit API reference","text":""},{"location":"references/apmodel/","title":"apmodel API reference","text":""},{"location":"references/apmodel/#apmodel.src.apmodel.Activity","title":"<code>Activity</code>","text":"<p>               Bases: <code>Object</code></p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>class Activity(Object):\n    def __init__(\n        self,\n        type: str = \"Activity\",\n        id: Optional[str] = None,\n        actor: Optional[Union[Object, Link, str, dict]] = None,\n        object: Optional[Union[Object, dict]] = None,\n        target: Optional[Union[Object, Link]] = None,\n        result: Optional[Union[Object, Link]] = None,\n        origin: Optional[Union[Object, Link]] = None,\n        instrument: Optional[Union[Object, Link]] = None,\n        proof: Union[DataIntegrityProof, dict] = {},\n        **kwargs,\n    ):\n        \"\"\"Represents an Activity object in Activity Streams 2.0.\n\n        The Activity class is used to express an action or event that occurs in a \n        social context. It encapsulates various properties that describe the \n        activity, including the actor, the object acted upon, and other related \n        entities.\n\n        Args:\n            type (str, optional): \n                The type of the object. For this class, it is always \"Activity\". \n                Defaults to \"Activity\".\n            id (Optional[str], optional): \n                A unique identifier for the activity. If not provided, a UUID \n                will be generated. Defaults to None.\n            actor (Optional[Union[Object, Link, str, dict]], optional): \n                The entity that is performing the activity. This can be an \n                Object, a Link, a string representing an identifier, or a \n                dictionary containing the entity's data. Defaults to None.\n            object (Optional[Union[Object, dict]], optional): \n                The object that is the target of the activity. This can be an \n                Object or a dictionary. Defaults to None.\n            target (Optional[Union[Object, Link]], optional): \n                The entity that the activity is directed towards. This can be \n                an Object or a Link. Defaults to None.\n            result (Optional[Union[Object, Link]], optional): \n                The result of the activity. This can be an Object or a Link \n                that represents the outcome of the activity. Defaults to None.\n            origin (Optional[Union[Object, Link]], optional): \n                The source of the activity, indicating where it originated. \n                This can be an Object or a Link. Defaults to None.\n            instrument (Optional[Union[Object, Link]], optional): \n                The tool or means used to perform the activity. This can be \n                an Object or a Link. Defaults to None.\n            proof (Union[DataIntegrityProof, dict], optional): \n                A proof of the integrity of the activity data, represented \n                as a DataIntegrityProof object or a dictionary. Defaults to \n                an empty list.\n            **kwargs: \n                Additional properties that can be added to the Activity \n                object, allowing for extensibility.\n\n        Note:\n            Other values are inherited from apmodel.Object.\n\n        Raises:\n            ValueError: \n                If the proof is not a valid DataIntegrityProof object or \n                dictionary.\n\n        \"\"\"\n        from .loader import load\n\n        super().__init__(type=\"Activity\", content=None)\n        self.type = type\n        self.id = id if id else str(uuid.uuid4())\n        self.published = (\n            datetime.utcnow().isoformat(timespec='microseconds').replace('+00:00', 'Z')\n            if not kwargs.get(\"published\")\n            else datetime.datetime.datetime.strptime(\n                kwargs.get(\"published\"), \"%Y-%m-%dT%H:%M:%S.%fZ\"\n            )\n        )\n        self.actor = load(actor) if isinstance(actor, dict) else actor\n        self.object = load(object) if isinstance(object, dict) else object\n        self.target = target\n        self.result = result\n        self.origin = origin\n        self.instrument = instrument\n        self.proof: Optional[DataIntegrityProof] = (load(proof) if isinstance(proof, dict) else proof) if proof != {} else None\n        self._extras = {}\n        for key, value in kwargs.items():\n            self._extras[key] = value\n\n    def accept(self, actor: Object | Link | str):\n        obj = self.to_dict(self._extras)\n        return _make_accept(obj, actor)\n\n    def reject(self, actor: Object | Link | str):\n        obj = self.to_dict(self._extras)\n        return _make_reject(obj, actor)\n\n    def to_dict(self, _extras: Optional[dict] = None) -&gt; dict:\n        \"\"\"Outputs the current object as a dictionary.\n\n        Args:\n            _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n\n        Returns:\n            dict: Objects converted to dictionaries\n        \"\"\"\n        data = super().to_dict()\n        data[\"@context\"] = [\"https://www.w3.org/ns/activitystreams\", \"https://w3id.org/security/data-integrity/v1\"]\n\n        if self.type:\n            data[\"type\"] = self.type\n        if self.actor:\n            data[\"actor\"] = (\n                self.actor.to_dict()\n                if isinstance(self.actor, Object)\n                else str(self.actor)\n            )\n        if self.object:\n            data[\"object\"] = (\n                self.object.to_dict()\n                if isinstance(self.object, Object)\n                else str(self.object)\n            )\n        if self.target:\n            data[\"target\"] = (\n                self.target.to_dict()\n                if isinstance(self.target, Object)\n                else str(self.target)\n            )\n        if self.proof:\n            data[\"proof\"] = (\n                self.target.to_dict()\n                if isinstance(self.proof, DataIntegrityProof)\n                else self.proof\n            )\n\n        return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.Activity.__init__","title":"<code>__init__(type='Activity', id=None, actor=None, object=None, target=None, result=None, origin=None, instrument=None, proof={}, **kwargs)</code>","text":"<p>Represents an Activity object in Activity Streams 2.0.</p> <p>The Activity class is used to express an action or event that occurs in a  social context. It encapsulates various properties that describe the  activity, including the actor, the object acted upon, and other related  entities.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>The type of the object. For this class, it is always \"Activity\".  Defaults to \"Activity\".</p> <code>'Activity'</code> <code>id</code> <code>Optional[str]</code> <p>A unique identifier for the activity. If not provided, a UUID  will be generated. Defaults to None.</p> <code>None</code> <code>actor</code> <code>Optional[Union[Object, Link, str, dict]]</code> <p>The entity that is performing the activity. This can be an  Object, a Link, a string representing an identifier, or a  dictionary containing the entity's data. Defaults to None.</p> <code>None</code> <code>object</code> <code>Optional[Union[Object, dict]]</code> <p>The object that is the target of the activity. This can be an  Object or a dictionary. Defaults to None.</p> <code>None</code> <code>target</code> <code>Optional[Union[Object, Link]]</code> <p>The entity that the activity is directed towards. This can be  an Object or a Link. Defaults to None.</p> <code>None</code> <code>result</code> <code>Optional[Union[Object, Link]]</code> <p>The result of the activity. This can be an Object or a Link  that represents the outcome of the activity. Defaults to None.</p> <code>None</code> <code>origin</code> <code>Optional[Union[Object, Link]]</code> <p>The source of the activity, indicating where it originated.  This can be an Object or a Link. Defaults to None.</p> <code>None</code> <code>instrument</code> <code>Optional[Union[Object, Link]]</code> <p>The tool or means used to perform the activity. This can be  an Object or a Link. Defaults to None.</p> <code>None</code> <code>proof</code> <code>Union[DataIntegrityProof, dict]</code> <p>A proof of the integrity of the activity data, represented  as a DataIntegrityProof object or a dictionary. Defaults to  an empty list.</p> <code>{}</code> <code>**kwargs</code> <p>Additional properties that can be added to the Activity  object, allowing for extensibility.</p> <code>{}</code> Note <p>Other values are inherited from apmodel.Object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the proof is not a valid DataIntegrityProof object or  dictionary.</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def __init__(\n    self,\n    type: str = \"Activity\",\n    id: Optional[str] = None,\n    actor: Optional[Union[Object, Link, str, dict]] = None,\n    object: Optional[Union[Object, dict]] = None,\n    target: Optional[Union[Object, Link]] = None,\n    result: Optional[Union[Object, Link]] = None,\n    origin: Optional[Union[Object, Link]] = None,\n    instrument: Optional[Union[Object, Link]] = None,\n    proof: Union[DataIntegrityProof, dict] = {},\n    **kwargs,\n):\n    \"\"\"Represents an Activity object in Activity Streams 2.0.\n\n    The Activity class is used to express an action or event that occurs in a \n    social context. It encapsulates various properties that describe the \n    activity, including the actor, the object acted upon, and other related \n    entities.\n\n    Args:\n        type (str, optional): \n            The type of the object. For this class, it is always \"Activity\". \n            Defaults to \"Activity\".\n        id (Optional[str], optional): \n            A unique identifier for the activity. If not provided, a UUID \n            will be generated. Defaults to None.\n        actor (Optional[Union[Object, Link, str, dict]], optional): \n            The entity that is performing the activity. This can be an \n            Object, a Link, a string representing an identifier, or a \n            dictionary containing the entity's data. Defaults to None.\n        object (Optional[Union[Object, dict]], optional): \n            The object that is the target of the activity. This can be an \n            Object or a dictionary. Defaults to None.\n        target (Optional[Union[Object, Link]], optional): \n            The entity that the activity is directed towards. This can be \n            an Object or a Link. Defaults to None.\n        result (Optional[Union[Object, Link]], optional): \n            The result of the activity. This can be an Object or a Link \n            that represents the outcome of the activity. Defaults to None.\n        origin (Optional[Union[Object, Link]], optional): \n            The source of the activity, indicating where it originated. \n            This can be an Object or a Link. Defaults to None.\n        instrument (Optional[Union[Object, Link]], optional): \n            The tool or means used to perform the activity. This can be \n            an Object or a Link. Defaults to None.\n        proof (Union[DataIntegrityProof, dict], optional): \n            A proof of the integrity of the activity data, represented \n            as a DataIntegrityProof object or a dictionary. Defaults to \n            an empty list.\n        **kwargs: \n            Additional properties that can be added to the Activity \n            object, allowing for extensibility.\n\n    Note:\n        Other values are inherited from apmodel.Object.\n\n    Raises:\n        ValueError: \n            If the proof is not a valid DataIntegrityProof object or \n            dictionary.\n\n    \"\"\"\n    from .loader import load\n\n    super().__init__(type=\"Activity\", content=None)\n    self.type = type\n    self.id = id if id else str(uuid.uuid4())\n    self.published = (\n        datetime.utcnow().isoformat(timespec='microseconds').replace('+00:00', 'Z')\n        if not kwargs.get(\"published\")\n        else datetime.datetime.datetime.strptime(\n            kwargs.get(\"published\"), \"%Y-%m-%dT%H:%M:%S.%fZ\"\n        )\n    )\n    self.actor = load(actor) if isinstance(actor, dict) else actor\n    self.object = load(object) if isinstance(object, dict) else object\n    self.target = target\n    self.result = result\n    self.origin = origin\n    self.instrument = instrument\n    self.proof: Optional[DataIntegrityProof] = (load(proof) if isinstance(proof, dict) else proof) if proof != {} else None\n    self._extras = {}\n    for key, value in kwargs.items():\n        self._extras[key] = value\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.Activity.to_dict","title":"<code>to_dict(_extras=None)</code>","text":"<p>Outputs the current object as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_extras</code> <code>Optional[dict]</code> <p>Arguments used internally. It is not recommended that users change them.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Objects converted to dictionaries</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def to_dict(self, _extras: Optional[dict] = None) -&gt; dict:\n    \"\"\"Outputs the current object as a dictionary.\n\n    Args:\n        _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n\n    Returns:\n        dict: Objects converted to dictionaries\n    \"\"\"\n    data = super().to_dict()\n    data[\"@context\"] = [\"https://www.w3.org/ns/activitystreams\", \"https://w3id.org/security/data-integrity/v1\"]\n\n    if self.type:\n        data[\"type\"] = self.type\n    if self.actor:\n        data[\"actor\"] = (\n            self.actor.to_dict()\n            if isinstance(self.actor, Object)\n            else str(self.actor)\n        )\n    if self.object:\n        data[\"object\"] = (\n            self.object.to_dict()\n            if isinstance(self.object, Object)\n            else str(self.object)\n        )\n    if self.target:\n        data[\"target\"] = (\n            self.target.to_dict()\n            if isinstance(self.target, Object)\n            else str(self.target)\n        )\n    if self.proof:\n        data[\"proof\"] = (\n            self.target.to_dict()\n            if isinstance(self.proof, DataIntegrityProof)\n            else self.proof\n        )\n\n    return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.Link","title":"<code>Link</code>","text":"Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>class Link:\n    def __init__(\n        self,\n        _context: Union[str, list] = \"https://www.w3.org/ns/activitystreams\",\n        type: str = \"Link\",\n        id: Optional[str] = None,\n        href: Optional[str] = None,\n        rel: Optional[list[str]] = None,\n        mediaType: Optional[str] = None,\n        name: Optional[str] = None,\n        hreflang: Optional[str] = None,\n        height: Optional[int] = None,\n        width: Optional[int] = None,\n        preview: Optional[Union[Object, \"Link\"]] = None,\n        **kwargs,\n    ):\n        \"\"\"Represents a Link object in Activity Streams 2.0.\n\n        This class implements the Link type, which is used to represent \n        a hyperlink to a resource. The Link object can contain various \n        attributes that provide metadata about the link.\n\n        Args:\n            _context (Union[str, list], optional): \n                The default value for @context. It can be a string \n                or a list of strings. Defaults to \"https://www.w3.org/ns/activitystreams\".\n            type (str, optional): \n                The type of the object. For this class, it is always \"Link\". \n                Defaults to \"Link\".\n            id (Optional[str], optional): \n                A unique identifier for the link object. \n                This can be a URL or an IRI. Defaults to None.\n            href (Optional[str], optional): \n                The URL that the link points to. It must conform to \n                the xsd:anyURI format. If provided, it must be a valid URI. \n                Defaults to None.\n            rel (Optional[list[str]], optional): \n                A list of relationship types indicating the nature \n                of the link with respect to the context of the link. \n                Defaults to None.\n            mediaType (Optional[str], optional): \n                The media type of the linked resource, such as \n                \"image/jpeg\". Defaults to None.\n            name (Optional[str], optional): \n                A human-readable name for the link. Defaults to None.\n            hreflang (Optional[str], optional): \n                The language of the linked resource, represented \n                as a language tag. Defaults to None.\n            height (Optional[int], optional): \n                The height of the linked resource in pixels. \n                Must be greater than or equal to 0. Defaults to None.\n            width (Optional[int], optional): \n                The width of the linked resource in pixels. \n                Must be greater than or equal to 0. Defaults to None.\n            preview (Optional[Union[\"Object\", \"Link\"]], optional): \n                A resource that provides a preview of the linked \n                content, which could be another Link or an Object. \n                Defaults to None.\n            **kwargs: \n                Additional properties that can be added to the Link \n                object, allowing for extensibility.\n\n        Raises:\n            ValueError: \n                If `href` is not a valid URI, if `height` is negative, \n                or if `width` is negative.\n\n        \"\"\"\n        if href:\n            if not re.fullmatch(r\"(%(?![0-9A-F]{2})|#.*#)\", href):\n                raise ValueError(\"href must be xsd:anyURI\")\n        if height:\n            if height &lt; 0:\n                raise ValueError(\"height must be greater than or equal to 0\")\n        if width:\n            if width &lt; 0:\n                raise ValueError(\"width must be greater than or equal to 0\")\n        ctx = kwargs.get(\"@context\")\n        self._context = merge_contexts(_context, ctx) if ctx else []\n        self.type = type\n        self.id = id\n        self.href = href\n        self.rel = rel\n        self.media_type = mediaType\n        self.name = name\n        self.hreflang = hreflang\n        self.height = height\n        self.preview = preview\n        self._extras = {}\n        for key, value in kwargs.items():\n            self._extras[key] = value\n\n    def to_dict(self, _extras: Optional[dict] = None, build_context: bool = True):\n        \"\"\"Outputs the current object as a dictionary.\n\n        Args:\n            _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n            build_context (bool): Do we automatically build @context based on the arguments? Defaults to False.\n\n        Returns:\n            dict: Objects converted to dictionaries\n        \"\"\"\n        if not _extras:\n            _extras = self._extras.copy()\n        instance_vars = vars(self).copy()\n\n        ctx = self._context.copy()\n        context = instance_vars.get(\"@context\")\n\n        if build_context:\n            attrs = dir(self)\n\n            ctx2 = []\n            ctx2_d = {}\n            if _extras.get(\"publicKey\") or \"publicKey\" in attrs:\n                ctx2.append(\"https://w3id.org/security/v1\")\n\n            # Mastodon\n            if _extras.get(\"featured\") or \"featured\" in attrs:\n                ctx2_d[\"featured\"] = {\n                    \"@id\": \"http://joinmastodon.org/ns#featured\",\n                    \"@type\": \"@id\",\n                }\n            if _extras.get(\"featuredTags\") or \"featuredTags\" in attrs:\n                ctx2_d[\"featuredTags\"] = {\n                    \"@id\": \"http://joinmastodon.org/ns#featuredTags\",\n                    \"@type\": \"@id\",\n                }\n            if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n                if not ctx2_d.get(\"toot\"):\n                    ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n                ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n            if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n                if not ctx2_d.get(\"toot\"):\n                    ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n                ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n            if (\n                _extras.get(\"manuallyApprovesFollowers\")\n                or \"manuallyApprovesFollowers\" in attrs\n            ):\n                ctx2_d[\"manuallyApprovesFollowers\"] = \"as:manuallyApprovesFollowers\"\n\n            # Misskey\n            if (\n                _extras.get(\"_misskey_content\")\n                or _extras.get(\"_misskey_summary\")\n                or _extras.get(\"_misskey_quote\")\n                or _extras.get(\"_misskey_reaction\")\n                or _extras.get(\"_misskey_votes\")\n                or _extras.get(\"_misskey_talk\")\n                or _extras.get(\"isCat\")\n                or _extras.get(\"_misskey_followedMessage\")\n                or _extras.get(\"_misskey_requireSigninToViewContents\")\n                or _extras.get(\"_misskey_makeNotesFollowersOnlyBefore\")\n                or _extras.get(\"_misskey_makeNotesHiddenBefore\")\n                or _extras.get(\"_misskey_license\")\n            ):\n                if not ctx2_d.get(\"misskey\"):\n                    ctx2_d[\"misskey\"] = \"https://misskey-hub-net/ns#\"\n\n            ctx2.append(ctx2_d)\n        if context:\n            context = merge_contexts(merge_contexts(ctx, context), ctx2)\n        else:\n            context = ctx\n        data: Dict[str, Any] = {\n            \"@context\": context,\n        }\n        for key, value in instance_vars.items():\n            if value is not None:\n                if not key.startswith(\"_\") and key != \"content\":\n                    if isinstance(value, datetime.datetime.datetime):\n                        data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                    elif isinstance(value, Object):\n                        data[key] = value.to_dict(_extras=value._extras)\n                    elif isinstance(value, list):\n                        data[key] = [\n                            item.to_dict(_extras=item._extras)\n                            if hasattr(item, \"to_dict\")\n                            else item\n                            for item in value\n                        ]\n                    elif (\n                        isinstance(value, dict)\n                        or isinstance(value, int)\n                        or isinstance(value, bool)\n                    ):\n                        data[key] = value\n                    else:\n                        data[key] = str(value)\n\n        _extras = _extras or {}\n        for key, value in self._extras.items():\n            if value is not None:\n                if isinstance(value, datetime.datetime.datetime):\n                    data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                elif isinstance(value, Object):\n                    data[key] = value.to_dict(_extras=value._extras)\n                elif isinstance(value, list):\n                    data[key] = [\n                        item.to_dict(_extras=item._extras)\n                        if hasattr(item, \"to_dict\")\n                        else item\n                        for item in value\n                    ]\n                elif (\n                    isinstance(value, dict)\n                    or isinstance(value, int)\n                    or isinstance(value, bool)\n                ):\n                    data[key] = value\n                else:\n                    data[key] = str(value)\n        return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.Link.__init__","title":"<code>__init__(_context='https://www.w3.org/ns/activitystreams', type='Link', id=None, href=None, rel=None, mediaType=None, name=None, hreflang=None, height=None, width=None, preview=None, **kwargs)</code>","text":"<p>Represents a Link object in Activity Streams 2.0.</p> <p>This class implements the Link type, which is used to represent  a hyperlink to a resource. The Link object can contain various  attributes that provide metadata about the link.</p> <p>Parameters:</p> Name Type Description Default <code>_context</code> <code>Union[str, list]</code> <p>The default value for @context. It can be a string  or a list of strings. Defaults to \"https://www.w3.org/ns/activitystreams\".</p> <code>'https://www.w3.org/ns/activitystreams'</code> <code>type</code> <code>str</code> <p>The type of the object. For this class, it is always \"Link\".  Defaults to \"Link\".</p> <code>'Link'</code> <code>id</code> <code>Optional[str]</code> <p>A unique identifier for the link object.  This can be a URL or an IRI. Defaults to None.</p> <code>None</code> <code>href</code> <code>Optional[str]</code> <p>The URL that the link points to. It must conform to  the xsd:anyURI format. If provided, it must be a valid URI.  Defaults to None.</p> <code>None</code> <code>rel</code> <code>Optional[list[str]]</code> <p>A list of relationship types indicating the nature  of the link with respect to the context of the link.  Defaults to None.</p> <code>None</code> <code>mediaType</code> <code>Optional[str]</code> <p>The media type of the linked resource, such as  \"image/jpeg\". Defaults to None.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>A human-readable name for the link. Defaults to None.</p> <code>None</code> <code>hreflang</code> <code>Optional[str]</code> <p>The language of the linked resource, represented  as a language tag. Defaults to None.</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height of the linked resource in pixels.  Must be greater than or equal to 0. Defaults to None.</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width of the linked resource in pixels.  Must be greater than or equal to 0. Defaults to None.</p> <code>None</code> <code>preview</code> <code>Optional[Union[Object, Link]]</code> <p>A resource that provides a preview of the linked  content, which could be another Link or an Object.  Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional properties that can be added to the Link  object, allowing for extensibility.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>href</code> is not a valid URI, if <code>height</code> is negative,  or if <code>width</code> is negative.</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def __init__(\n    self,\n    _context: Union[str, list] = \"https://www.w3.org/ns/activitystreams\",\n    type: str = \"Link\",\n    id: Optional[str] = None,\n    href: Optional[str] = None,\n    rel: Optional[list[str]] = None,\n    mediaType: Optional[str] = None,\n    name: Optional[str] = None,\n    hreflang: Optional[str] = None,\n    height: Optional[int] = None,\n    width: Optional[int] = None,\n    preview: Optional[Union[Object, \"Link\"]] = None,\n    **kwargs,\n):\n    \"\"\"Represents a Link object in Activity Streams 2.0.\n\n    This class implements the Link type, which is used to represent \n    a hyperlink to a resource. The Link object can contain various \n    attributes that provide metadata about the link.\n\n    Args:\n        _context (Union[str, list], optional): \n            The default value for @context. It can be a string \n            or a list of strings. Defaults to \"https://www.w3.org/ns/activitystreams\".\n        type (str, optional): \n            The type of the object. For this class, it is always \"Link\". \n            Defaults to \"Link\".\n        id (Optional[str], optional): \n            A unique identifier for the link object. \n            This can be a URL or an IRI. Defaults to None.\n        href (Optional[str], optional): \n            The URL that the link points to. It must conform to \n            the xsd:anyURI format. If provided, it must be a valid URI. \n            Defaults to None.\n        rel (Optional[list[str]], optional): \n            A list of relationship types indicating the nature \n            of the link with respect to the context of the link. \n            Defaults to None.\n        mediaType (Optional[str], optional): \n            The media type of the linked resource, such as \n            \"image/jpeg\". Defaults to None.\n        name (Optional[str], optional): \n            A human-readable name for the link. Defaults to None.\n        hreflang (Optional[str], optional): \n            The language of the linked resource, represented \n            as a language tag. Defaults to None.\n        height (Optional[int], optional): \n            The height of the linked resource in pixels. \n            Must be greater than or equal to 0. Defaults to None.\n        width (Optional[int], optional): \n            The width of the linked resource in pixels. \n            Must be greater than or equal to 0. Defaults to None.\n        preview (Optional[Union[\"Object\", \"Link\"]], optional): \n            A resource that provides a preview of the linked \n            content, which could be another Link or an Object. \n            Defaults to None.\n        **kwargs: \n            Additional properties that can be added to the Link \n            object, allowing for extensibility.\n\n    Raises:\n        ValueError: \n            If `href` is not a valid URI, if `height` is negative, \n            or if `width` is negative.\n\n    \"\"\"\n    if href:\n        if not re.fullmatch(r\"(%(?![0-9A-F]{2})|#.*#)\", href):\n            raise ValueError(\"href must be xsd:anyURI\")\n    if height:\n        if height &lt; 0:\n            raise ValueError(\"height must be greater than or equal to 0\")\n    if width:\n        if width &lt; 0:\n            raise ValueError(\"width must be greater than or equal to 0\")\n    ctx = kwargs.get(\"@context\")\n    self._context = merge_contexts(_context, ctx) if ctx else []\n    self.type = type\n    self.id = id\n    self.href = href\n    self.rel = rel\n    self.media_type = mediaType\n    self.name = name\n    self.hreflang = hreflang\n    self.height = height\n    self.preview = preview\n    self._extras = {}\n    for key, value in kwargs.items():\n        self._extras[key] = value\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.Link.to_dict","title":"<code>to_dict(_extras=None, build_context=True)</code>","text":"<p>Outputs the current object as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_extras</code> <code>Optional[dict]</code> <p>Arguments used internally. It is not recommended that users change them.</p> <code>None</code> <code>build_context</code> <code>bool</code> <p>Do we automatically build @context based on the arguments? Defaults to False.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Objects converted to dictionaries</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def to_dict(self, _extras: Optional[dict] = None, build_context: bool = True):\n    \"\"\"Outputs the current object as a dictionary.\n\n    Args:\n        _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n        build_context (bool): Do we automatically build @context based on the arguments? Defaults to False.\n\n    Returns:\n        dict: Objects converted to dictionaries\n    \"\"\"\n    if not _extras:\n        _extras = self._extras.copy()\n    instance_vars = vars(self).copy()\n\n    ctx = self._context.copy()\n    context = instance_vars.get(\"@context\")\n\n    if build_context:\n        attrs = dir(self)\n\n        ctx2 = []\n        ctx2_d = {}\n        if _extras.get(\"publicKey\") or \"publicKey\" in attrs:\n            ctx2.append(\"https://w3id.org/security/v1\")\n\n        # Mastodon\n        if _extras.get(\"featured\") or \"featured\" in attrs:\n            ctx2_d[\"featured\"] = {\n                \"@id\": \"http://joinmastodon.org/ns#featured\",\n                \"@type\": \"@id\",\n            }\n        if _extras.get(\"featuredTags\") or \"featuredTags\" in attrs:\n            ctx2_d[\"featuredTags\"] = {\n                \"@id\": \"http://joinmastodon.org/ns#featuredTags\",\n                \"@type\": \"@id\",\n            }\n        if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n            if not ctx2_d.get(\"toot\"):\n                ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n            ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n        if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n            if not ctx2_d.get(\"toot\"):\n                ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n            ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n        if (\n            _extras.get(\"manuallyApprovesFollowers\")\n            or \"manuallyApprovesFollowers\" in attrs\n        ):\n            ctx2_d[\"manuallyApprovesFollowers\"] = \"as:manuallyApprovesFollowers\"\n\n        # Misskey\n        if (\n            _extras.get(\"_misskey_content\")\n            or _extras.get(\"_misskey_summary\")\n            or _extras.get(\"_misskey_quote\")\n            or _extras.get(\"_misskey_reaction\")\n            or _extras.get(\"_misskey_votes\")\n            or _extras.get(\"_misskey_talk\")\n            or _extras.get(\"isCat\")\n            or _extras.get(\"_misskey_followedMessage\")\n            or _extras.get(\"_misskey_requireSigninToViewContents\")\n            or _extras.get(\"_misskey_makeNotesFollowersOnlyBefore\")\n            or _extras.get(\"_misskey_makeNotesHiddenBefore\")\n            or _extras.get(\"_misskey_license\")\n        ):\n            if not ctx2_d.get(\"misskey\"):\n                ctx2_d[\"misskey\"] = \"https://misskey-hub-net/ns#\"\n\n        ctx2.append(ctx2_d)\n    if context:\n        context = merge_contexts(merge_contexts(ctx, context), ctx2)\n    else:\n        context = ctx\n    data: Dict[str, Any] = {\n        \"@context\": context,\n    }\n    for key, value in instance_vars.items():\n        if value is not None:\n            if not key.startswith(\"_\") and key != \"content\":\n                if isinstance(value, datetime.datetime.datetime):\n                    data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                elif isinstance(value, Object):\n                    data[key] = value.to_dict(_extras=value._extras)\n                elif isinstance(value, list):\n                    data[key] = [\n                        item.to_dict(_extras=item._extras)\n                        if hasattr(item, \"to_dict\")\n                        else item\n                        for item in value\n                    ]\n                elif (\n                    isinstance(value, dict)\n                    or isinstance(value, int)\n                    or isinstance(value, bool)\n                ):\n                    data[key] = value\n                else:\n                    data[key] = str(value)\n\n    _extras = _extras or {}\n    for key, value in self._extras.items():\n        if value is not None:\n            if isinstance(value, datetime.datetime.datetime):\n                data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n            elif isinstance(value, Object):\n                data[key] = value.to_dict(_extras=value._extras)\n            elif isinstance(value, list):\n                data[key] = [\n                    item.to_dict(_extras=item._extras)\n                    if hasattr(item, \"to_dict\")\n                    else item\n                    for item in value\n                ]\n            elif (\n                isinstance(value, dict)\n                or isinstance(value, int)\n                or isinstance(value, bool)\n            ):\n                data[key] = value\n            else:\n                data[key] = str(value)\n    return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.Object","title":"<code>Object</code>","text":"Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>class Object:\n    def __init__(\n        self,\n        _context: Union[str, list] = \"https://www.w3.org/ns/activitystreams\",\n        type: str = \"Object\",\n        id: Optional[str] = None,\n        attachment: List[Union[\"Object\", \"Link\", dict]] = [],\n        attributedTo: Optional[Union[\"Object\", \"Link\", str]] = None,\n        audience: Optional[Union[\"Object\", \"Link\"]] = None,\n        content: Optional[str] = None,\n        context: Optional[Union[\"Object\", \"Link\"]] = None,\n        name: Optional[str] = None,\n        endTime: Optional[str] = None,\n        generator: Optional[Union[\"Object\", \"Link\"]] = None,\n        icon: Optional[Union[\"Image\", \"Link\"]] = None,\n        image: Optional[\"Image\"] = None,\n        inReplyTo: Optional[Union[\"Image\", \"Link\"]] = None,\n        location: Optional[Union[\"Image\", \"Link\"]] = None,\n        preview: Optional[Union[\"Object\", \"Link\"]] = None,\n        published: Optional[str] = None,\n        replies: Optional[\"Collection\"] = None,\n        startTime: Optional[str] = None,\n        summary: Optional[str] = None,\n        tag: Optional[Union[\"Object\", \"Link\"]] = None,\n        updated: Optional[str] = None,\n        url: Optional[Union[str, \"Link\"]] = None,\n        to: Optional[Union[\"Object\", \"Link\"]] = None,\n        bto: Optional[Union[\"Object\", \"Link\"]] = None,\n        cc: Optional[Union[\"Object\", \"Link\"]] = None,\n        bcc: Optional[Union[\"Object\", \"Link\"]] = None,\n        mediaType: Optional[str] = None,\n        duration: Optional[str] = None,\n        sensitive: Optional[bool] = None,\n        **kwargs,\n    ):\n        \"\"\"Implements the \"Object\" primary base type of the ActivityStreams vocabulary.\n\n        Args:\n            _context (Union[str, list], optional): \n                The default value for @context. Defaults to \"https://www.w3.org/ns/activitystreams\".\n            type (str, optional): \n                The name of the ActivityStreams type. Usually does not need to be changed. Defaults to \"Object\".\n            id (Optional[str], optional): \n                The identifier for the object. Defaults to None.\n            attachment (List[Union[\"Object\", \"Link\", dict]], optional): \n                A list of resources attached to the object. Defaults to an empty list.\n            attributedTo (Optional[Union[\"Object\", \"Link\", str]], optional): \n                The resource indicating the creator of this object. Defaults to None.\n            audience (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating the intended audience of this object. Defaults to None.\n            content (Optional[str], optional): \n                The text representing the content of the object. Defaults to None.\n            context (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating the context of the object. Defaults to None.\n            name (Optional[str], optional): \n                The name of the object. Defaults to None.\n            endTime (Optional[str], optional): \n                The end time of the event represented as an ISO8601 formatted string. Defaults to None.\n            generator (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating the application that generated the object. Defaults to None.\n            icon (Optional[Union[\"Image\", \"Link\"]], optional): \n                The resource for the icon of the object. Defaults to None.\n            image (Optional[\"Image\"], optional): \n                The resource for the image of the object. Defaults to None.\n            inReplyTo (Optional[Union[\"Image\", \"Link\"]], optional): \n                The resource indicating the target of this reply. Defaults to None.\n            location (Optional[Union[\"Image\", \"Link\"]], optional): \n                The resource indicating the location of the object. Defaults to None.\n            preview (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource for the preview of the object. Defaults to None.\n            published (Optional[str], optional): \n                The date and time when the object was published, represented as an ISO8601 formatted string. Defaults to None.\n            replies (Optional[\"Collection\"], optional): \n                A collection of replies to this object. Defaults to None.\n            startTime (Optional[str], optional): \n                The start time of the event represented as an ISO8601 formatted string. Defaults to None.\n            summary (Optional[str], optional): \n                A summary of the object. Defaults to None.\n            tag (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating tags related to the object. Defaults to None.\n            updated (Optional[str], optional): \n                The date and time when the object was last updated, represented as an ISO8601 formatted string. Defaults to None.\n            url (Optional[Union[str, \"Link\"]], optional): \n                The URL of the object. Defaults to None.\n            to (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating the recipient of the object. Defaults to None.\n            bto (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating BCC recipients. Defaults to None.\n            cc (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating CC recipients. Defaults to None.\n            bcc (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating BCC recipients. Defaults to None.\n            mediaType (Optional[str], optional): \n                The media type of the object. Defaults to None.\n            duration (Optional[str], optional): \n                A string representing the duration of the object. Defaults to None.\n            sensitive (Optional[bool], optional): \n                A flag indicating the sensitivity of the content. Defaults to None.\n\n        \"\"\"\n        from .loader import load\n\n        ctx = kwargs.get(\"@context\")\n        self._context = merge_contexts(_context, ctx) if ctx else []\n        self.type = type\n        self.id = id\n        self.attachment = [\n            load(attach) if isinstance(attach, dict) else attach\n            for attach in attachment\n        ]\n        self.attributedTo = (\n            load(attributedTo)\n            if isinstance(attributedTo, dict)\n            else attributedTo\n        )\n        self.audience = (\n            load(audience) if isinstance(audience, dict) else audience\n        )\n        self.content = content\n        self.context = (\n            load(context) if isinstance(context, dict) else context\n        )\n        self.name = name\n        self.endTime = (\n            (\n                endTime\n                if isinstance(endTime, datetime.datetime.datetime)\n                else datetime.datetime.datetime.strptime(\n                    endTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n                )\n            )\n            if endTime\n            else endTime\n        )\n        self.generator = (\n            load(generator) if isinstance(generator, dict) else generator\n        )\n        self.icon = load(icon) if isinstance(icon, dict) else icon\n        self.image = image\n        self.inReplyTo = (\n            load(inReplyTo) if isinstance(inReplyTo, dict) else inReplyTo\n        )\n        self.location = (\n            load(location) if isinstance(location, dict) else location\n        )\n        self.preview = (\n            load(preview) if isinstance(preview, dict) else preview\n        )\n        if published:\n            self.published = (\n                (\n                    published\n                    if isinstance(published, datetime.datetime.datetime)\n                    else datetime.datetime.datetime.strptime(\n                        published, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n                    )\n                )\n                if published\n                else published\n            )\n        else:\n            self.published = datetime.utcnow()\n        self.replies = (\n            load(replies) if isinstance(replies, dict) else replies\n        )\n        self.startTime = (\n            (\n                startTime\n                if isinstance(startTime, datetime.datetime.datetime)\n                else datetime.datetime.datetime.strptime(\n                    startTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n                )\n            )\n            if startTime\n            else startTime\n        )\n        self.summary = summary\n        self.tag = load(tag) if isinstance(tag, dict) else tag\n        self.updated = updated\n        self.url = load(url) if isinstance(url, dict) else url\n        self.to = load(to) if isinstance(to, dict) else to\n        self.bto = load(bto) if isinstance(bto, dict) else bto\n        self.cc = load(cc) if isinstance(cc, dict) else cc\n        self.bcc = load(bcc) if isinstance(bcc, dict) else bcc\n        self.mediaType = mediaType\n        self.duration = duration\n\n        # --- Extend Value\n        self.sensitive = sensitive\n        # ---\n\n        self._extras = {}\n        for key, value in kwargs.items():\n            self._extras[key] = value\n\n    def to_dict(self, _extras: Optional[dict] = None, build_context: bool = True):\n        \"\"\"Outputs the current object as a dictionary.\n\n        Args:\n            _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n            build_context (bool): Do we automatically build @context based on the arguments? Defaults to True.\n\n        Returns:\n            dict: Objects converted to dictionaries\n        \"\"\"\n        if not _extras:\n            _extras = self._extras.copy()\n        instance_vars = vars(self).copy()\n\n        ctx = self._context.copy()\n        if build_context:\n            attrs = dir(self)\n\n            ctx2 = []\n            ctx2_d = {}\n            if _extras.get(\"publicKey\") or \"publicKey\" in attrs:\n                ctx2.append(\"https://w3id.org/security/v1\")\n\n            # Mastodon\n            if _extras.get(\"featured\") or \"featured\" in attrs:\n                ctx2_d[\"featured\"] = {\n                    \"@id\": \"http://joinmastodon.org/ns#featured\",\n                    \"@type\": \"@id\",\n                }\n            if _extras.get(\"featuredTags\") or \"featuredTags\" in attrs:\n                ctx2_d[\"featuredTags\"] = {\n                    \"@id\": \"http://joinmastodon.org/ns#featuredTags\",\n                    \"@type\": \"@id\",\n                }\n            if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n                if not ctx2_d.get(\"toot\"):\n                    ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n                ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n            if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n                if not ctx2_d.get(\"toot\"):\n                    ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n                ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n            if (\n                _extras.get(\"manuallyApprovesFollowers\")\n                or \"manuallyApprovesFollowers\" in attrs\n            ):\n                ctx2_d[\"manuallyApprovesFollowers\"] = \"as:manuallyApprovesFollowers\"\n\n            # Misskey\n            if (\n                _extras.get(\"_misskey_content\")\n                or _extras.get(\"_misskey_summary\")\n                or _extras.get(\"_misskey_quote\")\n                or _extras.get(\"_misskey_reaction\")\n                or _extras.get(\"_misskey_votes\")\n                or _extras.get(\"_misskey_talk\")\n                or _extras.get(\"isCat\")\n                or _extras.get(\"_misskey_followedMessage\")\n                or _extras.get(\"_misskey_requireSigninToViewContents\")\n                or _extras.get(\"_misskey_makeNotesFollowersOnlyBefore\")\n                or _extras.get(\"_misskey_makeNotesHiddenBefore\")\n                or _extras.get(\"_misskey_license\")\n            ):\n                ctx2_d[\"misskey\"] = \"https://misskey-hub-net/ns#\"\n\n            ctx2.append(ctx2_d)\n\n        context: Optional[list] = instance_vars.get(\"@context\")\n        if context:\n            context = merge_contexts(merge_contexts(ctx, context), ctx2)\n        else:\n            context = ctx\n        data: Dict[str, Any] = {\n            \"@context\": context,\n        }\n\n        if self.content is not None:\n            data[\"content\"] = self.content\n\n        for key, value in instance_vars.items():\n            if value is not None:\n                if not key.startswith(\"_\") and key != \"content\":\n                    if isinstance(value, datetime.datetime.datetime):\n                        data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                    elif isinstance(value, Object):\n                        data[key] = value.to_dict(_extras=value._extras)\n                    elif isinstance(value, list):\n                        data[key] = [\n                            item.to_dict(_extras=item._extras)\n                            if hasattr(item, \"to_dict\")\n                            else item\n                            for item in value\n                        ]\n                    elif (\n                        isinstance(value, dict)\n                        or isinstance(value, int)\n                        or isinstance(value, bool)\n                    ):\n                        data[key] = value\n                    else:\n                        data[key] = str(value)\n\n        _extras = _extras or {}\n        for key, value in self._extras.items():\n            if value is not None:\n                if isinstance(value, datetime.datetime.datetime):\n                    data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                elif isinstance(value, Object):\n                    data[key] = value.to_dict(_extras=value._extras)\n                elif isinstance(value, list):\n                    data[key] = [\n                        item.to_dict(_extras=item._extras)\n                        if hasattr(item, \"to_dict\")\n                        else item\n                        for item in value\n                    ]\n                elif (\n                    isinstance(value, dict)\n                    or isinstance(value, int)\n                    or isinstance(value, bool)\n                ):\n                    data[key] = value\n                else:\n                    data[key] = str(value)\n        return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.Object.__init__","title":"<code>__init__(_context='https://www.w3.org/ns/activitystreams', type='Object', id=None, attachment=[], attributedTo=None, audience=None, content=None, context=None, name=None, endTime=None, generator=None, icon=None, image=None, inReplyTo=None, location=None, preview=None, published=None, replies=None, startTime=None, summary=None, tag=None, updated=None, url=None, to=None, bto=None, cc=None, bcc=None, mediaType=None, duration=None, sensitive=None, **kwargs)</code>","text":"<p>Implements the \"Object\" primary base type of the ActivityStreams vocabulary.</p> <p>Parameters:</p> Name Type Description Default <code>_context</code> <code>Union[str, list]</code> <p>The default value for @context. Defaults to \"https://www.w3.org/ns/activitystreams\".</p> <code>'https://www.w3.org/ns/activitystreams'</code> <code>type</code> <code>str</code> <p>The name of the ActivityStreams type. Usually does not need to be changed. Defaults to \"Object\".</p> <code>'Object'</code> <code>id</code> <code>Optional[str]</code> <p>The identifier for the object. Defaults to None.</p> <code>None</code> <code>attachment</code> <code>List[Union[Object, Link, dict]]</code> <p>A list of resources attached to the object. Defaults to an empty list.</p> <code>[]</code> <code>attributedTo</code> <code>Optional[Union[Object, Link, str]]</code> <p>The resource indicating the creator of this object. Defaults to None.</p> <code>None</code> <code>audience</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating the intended audience of this object. Defaults to None.</p> <code>None</code> <code>content</code> <code>Optional[str]</code> <p>The text representing the content of the object. Defaults to None.</p> <code>None</code> <code>context</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating the context of the object. Defaults to None.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>The name of the object. Defaults to None.</p> <code>None</code> <code>endTime</code> <code>Optional[str]</code> <p>The end time of the event represented as an ISO8601 formatted string. Defaults to None.</p> <code>None</code> <code>generator</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating the application that generated the object. Defaults to None.</p> <code>None</code> <code>icon</code> <code>Optional[Union[Image, Link]]</code> <p>The resource for the icon of the object. Defaults to None.</p> <code>None</code> <code>image</code> <code>Optional[Image]</code> <p>The resource for the image of the object. Defaults to None.</p> <code>None</code> <code>inReplyTo</code> <code>Optional[Union[Image, Link]]</code> <p>The resource indicating the target of this reply. Defaults to None.</p> <code>None</code> <code>location</code> <code>Optional[Union[Image, Link]]</code> <p>The resource indicating the location of the object. Defaults to None.</p> <code>None</code> <code>preview</code> <code>Optional[Union[Object, Link]]</code> <p>The resource for the preview of the object. Defaults to None.</p> <code>None</code> <code>published</code> <code>Optional[str]</code> <p>The date and time when the object was published, represented as an ISO8601 formatted string. Defaults to None.</p> <code>None</code> <code>replies</code> <code>Optional[Collection]</code> <p>A collection of replies to this object. Defaults to None.</p> <code>None</code> <code>startTime</code> <code>Optional[str]</code> <p>The start time of the event represented as an ISO8601 formatted string. Defaults to None.</p> <code>None</code> <code>summary</code> <code>Optional[str]</code> <p>A summary of the object. Defaults to None.</p> <code>None</code> <code>tag</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating tags related to the object. Defaults to None.</p> <code>None</code> <code>updated</code> <code>Optional[str]</code> <p>The date and time when the object was last updated, represented as an ISO8601 formatted string. Defaults to None.</p> <code>None</code> <code>url</code> <code>Optional[Union[str, Link]]</code> <p>The URL of the object. Defaults to None.</p> <code>None</code> <code>to</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating the recipient of the object. Defaults to None.</p> <code>None</code> <code>bto</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating BCC recipients. Defaults to None.</p> <code>None</code> <code>cc</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating CC recipients. Defaults to None.</p> <code>None</code> <code>bcc</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating BCC recipients. Defaults to None.</p> <code>None</code> <code>mediaType</code> <code>Optional[str]</code> <p>The media type of the object. Defaults to None.</p> <code>None</code> <code>duration</code> <code>Optional[str]</code> <p>A string representing the duration of the object. Defaults to None.</p> <code>None</code> <code>sensitive</code> <code>Optional[bool]</code> <p>A flag indicating the sensitivity of the content. Defaults to None.</p> <code>None</code> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def __init__(\n    self,\n    _context: Union[str, list] = \"https://www.w3.org/ns/activitystreams\",\n    type: str = \"Object\",\n    id: Optional[str] = None,\n    attachment: List[Union[\"Object\", \"Link\", dict]] = [],\n    attributedTo: Optional[Union[\"Object\", \"Link\", str]] = None,\n    audience: Optional[Union[\"Object\", \"Link\"]] = None,\n    content: Optional[str] = None,\n    context: Optional[Union[\"Object\", \"Link\"]] = None,\n    name: Optional[str] = None,\n    endTime: Optional[str] = None,\n    generator: Optional[Union[\"Object\", \"Link\"]] = None,\n    icon: Optional[Union[\"Image\", \"Link\"]] = None,\n    image: Optional[\"Image\"] = None,\n    inReplyTo: Optional[Union[\"Image\", \"Link\"]] = None,\n    location: Optional[Union[\"Image\", \"Link\"]] = None,\n    preview: Optional[Union[\"Object\", \"Link\"]] = None,\n    published: Optional[str] = None,\n    replies: Optional[\"Collection\"] = None,\n    startTime: Optional[str] = None,\n    summary: Optional[str] = None,\n    tag: Optional[Union[\"Object\", \"Link\"]] = None,\n    updated: Optional[str] = None,\n    url: Optional[Union[str, \"Link\"]] = None,\n    to: Optional[Union[\"Object\", \"Link\"]] = None,\n    bto: Optional[Union[\"Object\", \"Link\"]] = None,\n    cc: Optional[Union[\"Object\", \"Link\"]] = None,\n    bcc: Optional[Union[\"Object\", \"Link\"]] = None,\n    mediaType: Optional[str] = None,\n    duration: Optional[str] = None,\n    sensitive: Optional[bool] = None,\n    **kwargs,\n):\n    \"\"\"Implements the \"Object\" primary base type of the ActivityStreams vocabulary.\n\n    Args:\n        _context (Union[str, list], optional): \n            The default value for @context. Defaults to \"https://www.w3.org/ns/activitystreams\".\n        type (str, optional): \n            The name of the ActivityStreams type. Usually does not need to be changed. Defaults to \"Object\".\n        id (Optional[str], optional): \n            The identifier for the object. Defaults to None.\n        attachment (List[Union[\"Object\", \"Link\", dict]], optional): \n            A list of resources attached to the object. Defaults to an empty list.\n        attributedTo (Optional[Union[\"Object\", \"Link\", str]], optional): \n            The resource indicating the creator of this object. Defaults to None.\n        audience (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating the intended audience of this object. Defaults to None.\n        content (Optional[str], optional): \n            The text representing the content of the object. Defaults to None.\n        context (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating the context of the object. Defaults to None.\n        name (Optional[str], optional): \n            The name of the object. Defaults to None.\n        endTime (Optional[str], optional): \n            The end time of the event represented as an ISO8601 formatted string. Defaults to None.\n        generator (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating the application that generated the object. Defaults to None.\n        icon (Optional[Union[\"Image\", \"Link\"]], optional): \n            The resource for the icon of the object. Defaults to None.\n        image (Optional[\"Image\"], optional): \n            The resource for the image of the object. Defaults to None.\n        inReplyTo (Optional[Union[\"Image\", \"Link\"]], optional): \n            The resource indicating the target of this reply. Defaults to None.\n        location (Optional[Union[\"Image\", \"Link\"]], optional): \n            The resource indicating the location of the object. Defaults to None.\n        preview (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource for the preview of the object. Defaults to None.\n        published (Optional[str], optional): \n            The date and time when the object was published, represented as an ISO8601 formatted string. Defaults to None.\n        replies (Optional[\"Collection\"], optional): \n            A collection of replies to this object. Defaults to None.\n        startTime (Optional[str], optional): \n            The start time of the event represented as an ISO8601 formatted string. Defaults to None.\n        summary (Optional[str], optional): \n            A summary of the object. Defaults to None.\n        tag (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating tags related to the object. Defaults to None.\n        updated (Optional[str], optional): \n            The date and time when the object was last updated, represented as an ISO8601 formatted string. Defaults to None.\n        url (Optional[Union[str, \"Link\"]], optional): \n            The URL of the object. Defaults to None.\n        to (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating the recipient of the object. Defaults to None.\n        bto (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating BCC recipients. Defaults to None.\n        cc (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating CC recipients. Defaults to None.\n        bcc (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating BCC recipients. Defaults to None.\n        mediaType (Optional[str], optional): \n            The media type of the object. Defaults to None.\n        duration (Optional[str], optional): \n            A string representing the duration of the object. Defaults to None.\n        sensitive (Optional[bool], optional): \n            A flag indicating the sensitivity of the content. Defaults to None.\n\n    \"\"\"\n    from .loader import load\n\n    ctx = kwargs.get(\"@context\")\n    self._context = merge_contexts(_context, ctx) if ctx else []\n    self.type = type\n    self.id = id\n    self.attachment = [\n        load(attach) if isinstance(attach, dict) else attach\n        for attach in attachment\n    ]\n    self.attributedTo = (\n        load(attributedTo)\n        if isinstance(attributedTo, dict)\n        else attributedTo\n    )\n    self.audience = (\n        load(audience) if isinstance(audience, dict) else audience\n    )\n    self.content = content\n    self.context = (\n        load(context) if isinstance(context, dict) else context\n    )\n    self.name = name\n    self.endTime = (\n        (\n            endTime\n            if isinstance(endTime, datetime.datetime.datetime)\n            else datetime.datetime.datetime.strptime(\n                endTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n            )\n        )\n        if endTime\n        else endTime\n    )\n    self.generator = (\n        load(generator) if isinstance(generator, dict) else generator\n    )\n    self.icon = load(icon) if isinstance(icon, dict) else icon\n    self.image = image\n    self.inReplyTo = (\n        load(inReplyTo) if isinstance(inReplyTo, dict) else inReplyTo\n    )\n    self.location = (\n        load(location) if isinstance(location, dict) else location\n    )\n    self.preview = (\n        load(preview) if isinstance(preview, dict) else preview\n    )\n    if published:\n        self.published = (\n            (\n                published\n                if isinstance(published, datetime.datetime.datetime)\n                else datetime.datetime.datetime.strptime(\n                    published, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n                )\n            )\n            if published\n            else published\n        )\n    else:\n        self.published = datetime.utcnow()\n    self.replies = (\n        load(replies) if isinstance(replies, dict) else replies\n    )\n    self.startTime = (\n        (\n            startTime\n            if isinstance(startTime, datetime.datetime.datetime)\n            else datetime.datetime.datetime.strptime(\n                startTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n            )\n        )\n        if startTime\n        else startTime\n    )\n    self.summary = summary\n    self.tag = load(tag) if isinstance(tag, dict) else tag\n    self.updated = updated\n    self.url = load(url) if isinstance(url, dict) else url\n    self.to = load(to) if isinstance(to, dict) else to\n    self.bto = load(bto) if isinstance(bto, dict) else bto\n    self.cc = load(cc) if isinstance(cc, dict) else cc\n    self.bcc = load(bcc) if isinstance(bcc, dict) else bcc\n    self.mediaType = mediaType\n    self.duration = duration\n\n    # --- Extend Value\n    self.sensitive = sensitive\n    # ---\n\n    self._extras = {}\n    for key, value in kwargs.items():\n        self._extras[key] = value\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.Object.to_dict","title":"<code>to_dict(_extras=None, build_context=True)</code>","text":"<p>Outputs the current object as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_extras</code> <code>Optional[dict]</code> <p>Arguments used internally. It is not recommended that users change them.</p> <code>None</code> <code>build_context</code> <code>bool</code> <p>Do we automatically build @context based on the arguments? Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Objects converted to dictionaries</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def to_dict(self, _extras: Optional[dict] = None, build_context: bool = True):\n    \"\"\"Outputs the current object as a dictionary.\n\n    Args:\n        _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n        build_context (bool): Do we automatically build @context based on the arguments? Defaults to True.\n\n    Returns:\n        dict: Objects converted to dictionaries\n    \"\"\"\n    if not _extras:\n        _extras = self._extras.copy()\n    instance_vars = vars(self).copy()\n\n    ctx = self._context.copy()\n    if build_context:\n        attrs = dir(self)\n\n        ctx2 = []\n        ctx2_d = {}\n        if _extras.get(\"publicKey\") or \"publicKey\" in attrs:\n            ctx2.append(\"https://w3id.org/security/v1\")\n\n        # Mastodon\n        if _extras.get(\"featured\") or \"featured\" in attrs:\n            ctx2_d[\"featured\"] = {\n                \"@id\": \"http://joinmastodon.org/ns#featured\",\n                \"@type\": \"@id\",\n            }\n        if _extras.get(\"featuredTags\") or \"featuredTags\" in attrs:\n            ctx2_d[\"featuredTags\"] = {\n                \"@id\": \"http://joinmastodon.org/ns#featuredTags\",\n                \"@type\": \"@id\",\n            }\n        if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n            if not ctx2_d.get(\"toot\"):\n                ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n            ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n        if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n            if not ctx2_d.get(\"toot\"):\n                ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n            ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n        if (\n            _extras.get(\"manuallyApprovesFollowers\")\n            or \"manuallyApprovesFollowers\" in attrs\n        ):\n            ctx2_d[\"manuallyApprovesFollowers\"] = \"as:manuallyApprovesFollowers\"\n\n        # Misskey\n        if (\n            _extras.get(\"_misskey_content\")\n            or _extras.get(\"_misskey_summary\")\n            or _extras.get(\"_misskey_quote\")\n            or _extras.get(\"_misskey_reaction\")\n            or _extras.get(\"_misskey_votes\")\n            or _extras.get(\"_misskey_talk\")\n            or _extras.get(\"isCat\")\n            or _extras.get(\"_misskey_followedMessage\")\n            or _extras.get(\"_misskey_requireSigninToViewContents\")\n            or _extras.get(\"_misskey_makeNotesFollowersOnlyBefore\")\n            or _extras.get(\"_misskey_makeNotesHiddenBefore\")\n            or _extras.get(\"_misskey_license\")\n        ):\n            ctx2_d[\"misskey\"] = \"https://misskey-hub-net/ns#\"\n\n        ctx2.append(ctx2_d)\n\n    context: Optional[list] = instance_vars.get(\"@context\")\n    if context:\n        context = merge_contexts(merge_contexts(ctx, context), ctx2)\n    else:\n        context = ctx\n    data: Dict[str, Any] = {\n        \"@context\": context,\n    }\n\n    if self.content is not None:\n        data[\"content\"] = self.content\n\n    for key, value in instance_vars.items():\n        if value is not None:\n            if not key.startswith(\"_\") and key != \"content\":\n                if isinstance(value, datetime.datetime.datetime):\n                    data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                elif isinstance(value, Object):\n                    data[key] = value.to_dict(_extras=value._extras)\n                elif isinstance(value, list):\n                    data[key] = [\n                        item.to_dict(_extras=item._extras)\n                        if hasattr(item, \"to_dict\")\n                        else item\n                        for item in value\n                    ]\n                elif (\n                    isinstance(value, dict)\n                    or isinstance(value, int)\n                    or isinstance(value, bool)\n                ):\n                    data[key] = value\n                else:\n                    data[key] = str(value)\n\n    _extras = _extras or {}\n    for key, value in self._extras.items():\n        if value is not None:\n            if isinstance(value, datetime.datetime.datetime):\n                data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n            elif isinstance(value, Object):\n                data[key] = value.to_dict(_extras=value._extras)\n            elif isinstance(value, list):\n                data[key] = [\n                    item.to_dict(_extras=item._extras)\n                    if hasattr(item, \"to_dict\")\n                    else item\n                    for item in value\n                ]\n            elif (\n                isinstance(value, dict)\n                or isinstance(value, int)\n                or isinstance(value, bool)\n            ):\n                data[key] = value\n            else:\n                data[key] = str(value)\n    return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.StreamsLoader","title":"<code>StreamsLoader</code>","text":"Source code in <code>libs/apmodel/src/apmodel/loader.py</code> <pre><code>class StreamsLoader:\n    @staticmethod\n    @deprecated(\"StreamsLoader.load is deprecated; use loader.load.\")\n    def load(\n        object: dict[Any, Any], custom_mapper: dict = fedi_mapper\n    ) -&gt; Object | Link | Any | dict:  # type: ignore\n        \"\"\"convert json object to model\n\n        Args:\n            object (dict[Any, Any]): json object\n            custom_mapper (dict, optional): Models available at the time of loading. Defaults to fedi_mapper.\n\n        Returns:\n            Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.\n        \"\"\"\n        return load(object, custom_mapper)\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.StreamsLoader.load","title":"<code>load(object, custom_mapper=fedi_mapper)</code>  <code>staticmethod</code>","text":"<p>convert json object to model</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>dict[Any, Any]</code> <p>json object</p> required <code>custom_mapper</code> <code>dict</code> <p>Models available at the time of loading. Defaults to fedi_mapper.</p> <code>fedi_mapper</code> <p>Returns:</p> Type Description <code>Object | Link | Any | dict</code> <p>Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.</p> Source code in <code>libs/apmodel/src/apmodel/loader.py</code> <pre><code>@staticmethod\n@deprecated(\"StreamsLoader.load is deprecated; use loader.load.\")\ndef load(\n    object: dict[Any, Any], custom_mapper: dict = fedi_mapper\n) -&gt; Object | Link | Any | dict:  # type: ignore\n    \"\"\"convert json object to model\n\n    Args:\n        object (dict[Any, Any]): json object\n        custom_mapper (dict, optional): Models available at the time of loading. Defaults to fedi_mapper.\n\n    Returns:\n        Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.\n    \"\"\"\n    return load(object, custom_mapper)\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.load","title":"<code>load(object, custom_mapper=fedi_mapper)</code>","text":"<p>convert json object to model</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>dict[Any, Any]</code> <p>json object</p> required <code>custom_mapper</code> <code>dict</code> <p>Models available at the time of loading. Defaults to fedi_mapper.</p> <code>fedi_mapper</code> <p>Returns:</p> Type Description <code>Object | Link | dict | Any</code> <p>Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.</p> Source code in <code>libs/apmodel/src/apmodel/loader.py</code> <pre><code>def load(\n    object: dict[Any, Any], custom_mapper: dict = fedi_mapper\n) -&gt; Object | Link | dict | Any:  # type: ignore\n    \"\"\"convert json object to model\n\n    Args:\n        object (dict[Any, Any]): json object\n        custom_mapper (dict, optional): Models available at the time of loading. Defaults to fedi_mapper.\n\n    Returns:\n        Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.\n    \"\"\"\n    type = object.get(\"type\")\n    cls = custom_mapper.get(type)\n    if cls:\n        return cls(**object)\n    return object\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core","title":"<code>core</code>","text":""},{"location":"references/apmodel/#apmodel.src.apmodel.core.Activity","title":"<code>Activity</code>","text":"<p>               Bases: <code>Object</code></p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>class Activity(Object):\n    def __init__(\n        self,\n        type: str = \"Activity\",\n        id: Optional[str] = None,\n        actor: Optional[Union[Object, Link, str, dict]] = None,\n        object: Optional[Union[Object, dict]] = None,\n        target: Optional[Union[Object, Link]] = None,\n        result: Optional[Union[Object, Link]] = None,\n        origin: Optional[Union[Object, Link]] = None,\n        instrument: Optional[Union[Object, Link]] = None,\n        proof: Union[DataIntegrityProof, dict] = {},\n        **kwargs,\n    ):\n        \"\"\"Represents an Activity object in Activity Streams 2.0.\n\n        The Activity class is used to express an action or event that occurs in a \n        social context. It encapsulates various properties that describe the \n        activity, including the actor, the object acted upon, and other related \n        entities.\n\n        Args:\n            type (str, optional): \n                The type of the object. For this class, it is always \"Activity\". \n                Defaults to \"Activity\".\n            id (Optional[str], optional): \n                A unique identifier for the activity. If not provided, a UUID \n                will be generated. Defaults to None.\n            actor (Optional[Union[Object, Link, str, dict]], optional): \n                The entity that is performing the activity. This can be an \n                Object, a Link, a string representing an identifier, or a \n                dictionary containing the entity's data. Defaults to None.\n            object (Optional[Union[Object, dict]], optional): \n                The object that is the target of the activity. This can be an \n                Object or a dictionary. Defaults to None.\n            target (Optional[Union[Object, Link]], optional): \n                The entity that the activity is directed towards. This can be \n                an Object or a Link. Defaults to None.\n            result (Optional[Union[Object, Link]], optional): \n                The result of the activity. This can be an Object or a Link \n                that represents the outcome of the activity. Defaults to None.\n            origin (Optional[Union[Object, Link]], optional): \n                The source of the activity, indicating where it originated. \n                This can be an Object or a Link. Defaults to None.\n            instrument (Optional[Union[Object, Link]], optional): \n                The tool or means used to perform the activity. This can be \n                an Object or a Link. Defaults to None.\n            proof (Union[DataIntegrityProof, dict], optional): \n                A proof of the integrity of the activity data, represented \n                as a DataIntegrityProof object or a dictionary. Defaults to \n                an empty list.\n            **kwargs: \n                Additional properties that can be added to the Activity \n                object, allowing for extensibility.\n\n        Note:\n            Other values are inherited from apmodel.Object.\n\n        Raises:\n            ValueError: \n                If the proof is not a valid DataIntegrityProof object or \n                dictionary.\n\n        \"\"\"\n        from .loader import load\n\n        super().__init__(type=\"Activity\", content=None)\n        self.type = type\n        self.id = id if id else str(uuid.uuid4())\n        self.published = (\n            datetime.utcnow().isoformat(timespec='microseconds').replace('+00:00', 'Z')\n            if not kwargs.get(\"published\")\n            else datetime.datetime.datetime.strptime(\n                kwargs.get(\"published\"), \"%Y-%m-%dT%H:%M:%S.%fZ\"\n            )\n        )\n        self.actor = load(actor) if isinstance(actor, dict) else actor\n        self.object = load(object) if isinstance(object, dict) else object\n        self.target = target\n        self.result = result\n        self.origin = origin\n        self.instrument = instrument\n        self.proof: Optional[DataIntegrityProof] = (load(proof) if isinstance(proof, dict) else proof) if proof != {} else None\n        self._extras = {}\n        for key, value in kwargs.items():\n            self._extras[key] = value\n\n    def accept(self, actor: Object | Link | str):\n        obj = self.to_dict(self._extras)\n        return _make_accept(obj, actor)\n\n    def reject(self, actor: Object | Link | str):\n        obj = self.to_dict(self._extras)\n        return _make_reject(obj, actor)\n\n    def to_dict(self, _extras: Optional[dict] = None) -&gt; dict:\n        \"\"\"Outputs the current object as a dictionary.\n\n        Args:\n            _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n\n        Returns:\n            dict: Objects converted to dictionaries\n        \"\"\"\n        data = super().to_dict()\n        data[\"@context\"] = [\"https://www.w3.org/ns/activitystreams\", \"https://w3id.org/security/data-integrity/v1\"]\n\n        if self.type:\n            data[\"type\"] = self.type\n        if self.actor:\n            data[\"actor\"] = (\n                self.actor.to_dict()\n                if isinstance(self.actor, Object)\n                else str(self.actor)\n            )\n        if self.object:\n            data[\"object\"] = (\n                self.object.to_dict()\n                if isinstance(self.object, Object)\n                else str(self.object)\n            )\n        if self.target:\n            data[\"target\"] = (\n                self.target.to_dict()\n                if isinstance(self.target, Object)\n                else str(self.target)\n            )\n        if self.proof:\n            data[\"proof\"] = (\n                self.target.to_dict()\n                if isinstance(self.proof, DataIntegrityProof)\n                else self.proof\n            )\n\n        return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core.Activity.__init__","title":"<code>__init__(type='Activity', id=None, actor=None, object=None, target=None, result=None, origin=None, instrument=None, proof={}, **kwargs)</code>","text":"<p>Represents an Activity object in Activity Streams 2.0.</p> <p>The Activity class is used to express an action or event that occurs in a  social context. It encapsulates various properties that describe the  activity, including the actor, the object acted upon, and other related  entities.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>The type of the object. For this class, it is always \"Activity\".  Defaults to \"Activity\".</p> <code>'Activity'</code> <code>id</code> <code>Optional[str]</code> <p>A unique identifier for the activity. If not provided, a UUID  will be generated. Defaults to None.</p> <code>None</code> <code>actor</code> <code>Optional[Union[Object, Link, str, dict]]</code> <p>The entity that is performing the activity. This can be an  Object, a Link, a string representing an identifier, or a  dictionary containing the entity's data. Defaults to None.</p> <code>None</code> <code>object</code> <code>Optional[Union[Object, dict]]</code> <p>The object that is the target of the activity. This can be an  Object or a dictionary. Defaults to None.</p> <code>None</code> <code>target</code> <code>Optional[Union[Object, Link]]</code> <p>The entity that the activity is directed towards. This can be  an Object or a Link. Defaults to None.</p> <code>None</code> <code>result</code> <code>Optional[Union[Object, Link]]</code> <p>The result of the activity. This can be an Object or a Link  that represents the outcome of the activity. Defaults to None.</p> <code>None</code> <code>origin</code> <code>Optional[Union[Object, Link]]</code> <p>The source of the activity, indicating where it originated.  This can be an Object or a Link. Defaults to None.</p> <code>None</code> <code>instrument</code> <code>Optional[Union[Object, Link]]</code> <p>The tool or means used to perform the activity. This can be  an Object or a Link. Defaults to None.</p> <code>None</code> <code>proof</code> <code>Union[DataIntegrityProof, dict]</code> <p>A proof of the integrity of the activity data, represented  as a DataIntegrityProof object or a dictionary. Defaults to  an empty list.</p> <code>{}</code> <code>**kwargs</code> <p>Additional properties that can be added to the Activity  object, allowing for extensibility.</p> <code>{}</code> Note <p>Other values are inherited from apmodel.Object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the proof is not a valid DataIntegrityProof object or  dictionary.</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def __init__(\n    self,\n    type: str = \"Activity\",\n    id: Optional[str] = None,\n    actor: Optional[Union[Object, Link, str, dict]] = None,\n    object: Optional[Union[Object, dict]] = None,\n    target: Optional[Union[Object, Link]] = None,\n    result: Optional[Union[Object, Link]] = None,\n    origin: Optional[Union[Object, Link]] = None,\n    instrument: Optional[Union[Object, Link]] = None,\n    proof: Union[DataIntegrityProof, dict] = {},\n    **kwargs,\n):\n    \"\"\"Represents an Activity object in Activity Streams 2.0.\n\n    The Activity class is used to express an action or event that occurs in a \n    social context. It encapsulates various properties that describe the \n    activity, including the actor, the object acted upon, and other related \n    entities.\n\n    Args:\n        type (str, optional): \n            The type of the object. For this class, it is always \"Activity\". \n            Defaults to \"Activity\".\n        id (Optional[str], optional): \n            A unique identifier for the activity. If not provided, a UUID \n            will be generated. Defaults to None.\n        actor (Optional[Union[Object, Link, str, dict]], optional): \n            The entity that is performing the activity. This can be an \n            Object, a Link, a string representing an identifier, or a \n            dictionary containing the entity's data. Defaults to None.\n        object (Optional[Union[Object, dict]], optional): \n            The object that is the target of the activity. This can be an \n            Object or a dictionary. Defaults to None.\n        target (Optional[Union[Object, Link]], optional): \n            The entity that the activity is directed towards. This can be \n            an Object or a Link. Defaults to None.\n        result (Optional[Union[Object, Link]], optional): \n            The result of the activity. This can be an Object or a Link \n            that represents the outcome of the activity. Defaults to None.\n        origin (Optional[Union[Object, Link]], optional): \n            The source of the activity, indicating where it originated. \n            This can be an Object or a Link. Defaults to None.\n        instrument (Optional[Union[Object, Link]], optional): \n            The tool or means used to perform the activity. This can be \n            an Object or a Link. Defaults to None.\n        proof (Union[DataIntegrityProof, dict], optional): \n            A proof of the integrity of the activity data, represented \n            as a DataIntegrityProof object or a dictionary. Defaults to \n            an empty list.\n        **kwargs: \n            Additional properties that can be added to the Activity \n            object, allowing for extensibility.\n\n    Note:\n        Other values are inherited from apmodel.Object.\n\n    Raises:\n        ValueError: \n            If the proof is not a valid DataIntegrityProof object or \n            dictionary.\n\n    \"\"\"\n    from .loader import load\n\n    super().__init__(type=\"Activity\", content=None)\n    self.type = type\n    self.id = id if id else str(uuid.uuid4())\n    self.published = (\n        datetime.utcnow().isoformat(timespec='microseconds').replace('+00:00', 'Z')\n        if not kwargs.get(\"published\")\n        else datetime.datetime.datetime.strptime(\n            kwargs.get(\"published\"), \"%Y-%m-%dT%H:%M:%S.%fZ\"\n        )\n    )\n    self.actor = load(actor) if isinstance(actor, dict) else actor\n    self.object = load(object) if isinstance(object, dict) else object\n    self.target = target\n    self.result = result\n    self.origin = origin\n    self.instrument = instrument\n    self.proof: Optional[DataIntegrityProof] = (load(proof) if isinstance(proof, dict) else proof) if proof != {} else None\n    self._extras = {}\n    for key, value in kwargs.items():\n        self._extras[key] = value\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core.Activity.to_dict","title":"<code>to_dict(_extras=None)</code>","text":"<p>Outputs the current object as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_extras</code> <code>Optional[dict]</code> <p>Arguments used internally. It is not recommended that users change them.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Objects converted to dictionaries</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def to_dict(self, _extras: Optional[dict] = None) -&gt; dict:\n    \"\"\"Outputs the current object as a dictionary.\n\n    Args:\n        _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n\n    Returns:\n        dict: Objects converted to dictionaries\n    \"\"\"\n    data = super().to_dict()\n    data[\"@context\"] = [\"https://www.w3.org/ns/activitystreams\", \"https://w3id.org/security/data-integrity/v1\"]\n\n    if self.type:\n        data[\"type\"] = self.type\n    if self.actor:\n        data[\"actor\"] = (\n            self.actor.to_dict()\n            if isinstance(self.actor, Object)\n            else str(self.actor)\n        )\n    if self.object:\n        data[\"object\"] = (\n            self.object.to_dict()\n            if isinstance(self.object, Object)\n            else str(self.object)\n        )\n    if self.target:\n        data[\"target\"] = (\n            self.target.to_dict()\n            if isinstance(self.target, Object)\n            else str(self.target)\n        )\n    if self.proof:\n        data[\"proof\"] = (\n            self.target.to_dict()\n            if isinstance(self.proof, DataIntegrityProof)\n            else self.proof\n        )\n\n    return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core.Link","title":"<code>Link</code>","text":"Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>class Link:\n    def __init__(\n        self,\n        _context: Union[str, list] = \"https://www.w3.org/ns/activitystreams\",\n        type: str = \"Link\",\n        id: Optional[str] = None,\n        href: Optional[str] = None,\n        rel: Optional[list[str]] = None,\n        mediaType: Optional[str] = None,\n        name: Optional[str] = None,\n        hreflang: Optional[str] = None,\n        height: Optional[int] = None,\n        width: Optional[int] = None,\n        preview: Optional[Union[Object, \"Link\"]] = None,\n        **kwargs,\n    ):\n        \"\"\"Represents a Link object in Activity Streams 2.0.\n\n        This class implements the Link type, which is used to represent \n        a hyperlink to a resource. The Link object can contain various \n        attributes that provide metadata about the link.\n\n        Args:\n            _context (Union[str, list], optional): \n                The default value for @context. It can be a string \n                or a list of strings. Defaults to \"https://www.w3.org/ns/activitystreams\".\n            type (str, optional): \n                The type of the object. For this class, it is always \"Link\". \n                Defaults to \"Link\".\n            id (Optional[str], optional): \n                A unique identifier for the link object. \n                This can be a URL or an IRI. Defaults to None.\n            href (Optional[str], optional): \n                The URL that the link points to. It must conform to \n                the xsd:anyURI format. If provided, it must be a valid URI. \n                Defaults to None.\n            rel (Optional[list[str]], optional): \n                A list of relationship types indicating the nature \n                of the link with respect to the context of the link. \n                Defaults to None.\n            mediaType (Optional[str], optional): \n                The media type of the linked resource, such as \n                \"image/jpeg\". Defaults to None.\n            name (Optional[str], optional): \n                A human-readable name for the link. Defaults to None.\n            hreflang (Optional[str], optional): \n                The language of the linked resource, represented \n                as a language tag. Defaults to None.\n            height (Optional[int], optional): \n                The height of the linked resource in pixels. \n                Must be greater than or equal to 0. Defaults to None.\n            width (Optional[int], optional): \n                The width of the linked resource in pixels. \n                Must be greater than or equal to 0. Defaults to None.\n            preview (Optional[Union[\"Object\", \"Link\"]], optional): \n                A resource that provides a preview of the linked \n                content, which could be another Link or an Object. \n                Defaults to None.\n            **kwargs: \n                Additional properties that can be added to the Link \n                object, allowing for extensibility.\n\n        Raises:\n            ValueError: \n                If `href` is not a valid URI, if `height` is negative, \n                or if `width` is negative.\n\n        \"\"\"\n        if href:\n            if not re.fullmatch(r\"(%(?![0-9A-F]{2})|#.*#)\", href):\n                raise ValueError(\"href must be xsd:anyURI\")\n        if height:\n            if height &lt; 0:\n                raise ValueError(\"height must be greater than or equal to 0\")\n        if width:\n            if width &lt; 0:\n                raise ValueError(\"width must be greater than or equal to 0\")\n        ctx = kwargs.get(\"@context\")\n        self._context = merge_contexts(_context, ctx) if ctx else []\n        self.type = type\n        self.id = id\n        self.href = href\n        self.rel = rel\n        self.media_type = mediaType\n        self.name = name\n        self.hreflang = hreflang\n        self.height = height\n        self.preview = preview\n        self._extras = {}\n        for key, value in kwargs.items():\n            self._extras[key] = value\n\n    def to_dict(self, _extras: Optional[dict] = None, build_context: bool = True):\n        \"\"\"Outputs the current object as a dictionary.\n\n        Args:\n            _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n            build_context (bool): Do we automatically build @context based on the arguments? Defaults to False.\n\n        Returns:\n            dict: Objects converted to dictionaries\n        \"\"\"\n        if not _extras:\n            _extras = self._extras.copy()\n        instance_vars = vars(self).copy()\n\n        ctx = self._context.copy()\n        context = instance_vars.get(\"@context\")\n\n        if build_context:\n            attrs = dir(self)\n\n            ctx2 = []\n            ctx2_d = {}\n            if _extras.get(\"publicKey\") or \"publicKey\" in attrs:\n                ctx2.append(\"https://w3id.org/security/v1\")\n\n            # Mastodon\n            if _extras.get(\"featured\") or \"featured\" in attrs:\n                ctx2_d[\"featured\"] = {\n                    \"@id\": \"http://joinmastodon.org/ns#featured\",\n                    \"@type\": \"@id\",\n                }\n            if _extras.get(\"featuredTags\") or \"featuredTags\" in attrs:\n                ctx2_d[\"featuredTags\"] = {\n                    \"@id\": \"http://joinmastodon.org/ns#featuredTags\",\n                    \"@type\": \"@id\",\n                }\n            if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n                if not ctx2_d.get(\"toot\"):\n                    ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n                ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n            if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n                if not ctx2_d.get(\"toot\"):\n                    ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n                ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n            if (\n                _extras.get(\"manuallyApprovesFollowers\")\n                or \"manuallyApprovesFollowers\" in attrs\n            ):\n                ctx2_d[\"manuallyApprovesFollowers\"] = \"as:manuallyApprovesFollowers\"\n\n            # Misskey\n            if (\n                _extras.get(\"_misskey_content\")\n                or _extras.get(\"_misskey_summary\")\n                or _extras.get(\"_misskey_quote\")\n                or _extras.get(\"_misskey_reaction\")\n                or _extras.get(\"_misskey_votes\")\n                or _extras.get(\"_misskey_talk\")\n                or _extras.get(\"isCat\")\n                or _extras.get(\"_misskey_followedMessage\")\n                or _extras.get(\"_misskey_requireSigninToViewContents\")\n                or _extras.get(\"_misskey_makeNotesFollowersOnlyBefore\")\n                or _extras.get(\"_misskey_makeNotesHiddenBefore\")\n                or _extras.get(\"_misskey_license\")\n            ):\n                if not ctx2_d.get(\"misskey\"):\n                    ctx2_d[\"misskey\"] = \"https://misskey-hub-net/ns#\"\n\n            ctx2.append(ctx2_d)\n        if context:\n            context = merge_contexts(merge_contexts(ctx, context), ctx2)\n        else:\n            context = ctx\n        data: Dict[str, Any] = {\n            \"@context\": context,\n        }\n        for key, value in instance_vars.items():\n            if value is not None:\n                if not key.startswith(\"_\") and key != \"content\":\n                    if isinstance(value, datetime.datetime.datetime):\n                        data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                    elif isinstance(value, Object):\n                        data[key] = value.to_dict(_extras=value._extras)\n                    elif isinstance(value, list):\n                        data[key] = [\n                            item.to_dict(_extras=item._extras)\n                            if hasattr(item, \"to_dict\")\n                            else item\n                            for item in value\n                        ]\n                    elif (\n                        isinstance(value, dict)\n                        or isinstance(value, int)\n                        or isinstance(value, bool)\n                    ):\n                        data[key] = value\n                    else:\n                        data[key] = str(value)\n\n        _extras = _extras or {}\n        for key, value in self._extras.items():\n            if value is not None:\n                if isinstance(value, datetime.datetime.datetime):\n                    data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                elif isinstance(value, Object):\n                    data[key] = value.to_dict(_extras=value._extras)\n                elif isinstance(value, list):\n                    data[key] = [\n                        item.to_dict(_extras=item._extras)\n                        if hasattr(item, \"to_dict\")\n                        else item\n                        for item in value\n                    ]\n                elif (\n                    isinstance(value, dict)\n                    or isinstance(value, int)\n                    or isinstance(value, bool)\n                ):\n                    data[key] = value\n                else:\n                    data[key] = str(value)\n        return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core.Link.__init__","title":"<code>__init__(_context='https://www.w3.org/ns/activitystreams', type='Link', id=None, href=None, rel=None, mediaType=None, name=None, hreflang=None, height=None, width=None, preview=None, **kwargs)</code>","text":"<p>Represents a Link object in Activity Streams 2.0.</p> <p>This class implements the Link type, which is used to represent  a hyperlink to a resource. The Link object can contain various  attributes that provide metadata about the link.</p> <p>Parameters:</p> Name Type Description Default <code>_context</code> <code>Union[str, list]</code> <p>The default value for @context. It can be a string  or a list of strings. Defaults to \"https://www.w3.org/ns/activitystreams\".</p> <code>'https://www.w3.org/ns/activitystreams'</code> <code>type</code> <code>str</code> <p>The type of the object. For this class, it is always \"Link\".  Defaults to \"Link\".</p> <code>'Link'</code> <code>id</code> <code>Optional[str]</code> <p>A unique identifier for the link object.  This can be a URL or an IRI. Defaults to None.</p> <code>None</code> <code>href</code> <code>Optional[str]</code> <p>The URL that the link points to. It must conform to  the xsd:anyURI format. If provided, it must be a valid URI.  Defaults to None.</p> <code>None</code> <code>rel</code> <code>Optional[list[str]]</code> <p>A list of relationship types indicating the nature  of the link with respect to the context of the link.  Defaults to None.</p> <code>None</code> <code>mediaType</code> <code>Optional[str]</code> <p>The media type of the linked resource, such as  \"image/jpeg\". Defaults to None.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>A human-readable name for the link. Defaults to None.</p> <code>None</code> <code>hreflang</code> <code>Optional[str]</code> <p>The language of the linked resource, represented  as a language tag. Defaults to None.</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height of the linked resource in pixels.  Must be greater than or equal to 0. Defaults to None.</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width of the linked resource in pixels.  Must be greater than or equal to 0. Defaults to None.</p> <code>None</code> <code>preview</code> <code>Optional[Union[Object, Link]]</code> <p>A resource that provides a preview of the linked  content, which could be another Link or an Object.  Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional properties that can be added to the Link  object, allowing for extensibility.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>href</code> is not a valid URI, if <code>height</code> is negative,  or if <code>width</code> is negative.</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def __init__(\n    self,\n    _context: Union[str, list] = \"https://www.w3.org/ns/activitystreams\",\n    type: str = \"Link\",\n    id: Optional[str] = None,\n    href: Optional[str] = None,\n    rel: Optional[list[str]] = None,\n    mediaType: Optional[str] = None,\n    name: Optional[str] = None,\n    hreflang: Optional[str] = None,\n    height: Optional[int] = None,\n    width: Optional[int] = None,\n    preview: Optional[Union[Object, \"Link\"]] = None,\n    **kwargs,\n):\n    \"\"\"Represents a Link object in Activity Streams 2.0.\n\n    This class implements the Link type, which is used to represent \n    a hyperlink to a resource. The Link object can contain various \n    attributes that provide metadata about the link.\n\n    Args:\n        _context (Union[str, list], optional): \n            The default value for @context. It can be a string \n            or a list of strings. Defaults to \"https://www.w3.org/ns/activitystreams\".\n        type (str, optional): \n            The type of the object. For this class, it is always \"Link\". \n            Defaults to \"Link\".\n        id (Optional[str], optional): \n            A unique identifier for the link object. \n            This can be a URL or an IRI. Defaults to None.\n        href (Optional[str], optional): \n            The URL that the link points to. It must conform to \n            the xsd:anyURI format. If provided, it must be a valid URI. \n            Defaults to None.\n        rel (Optional[list[str]], optional): \n            A list of relationship types indicating the nature \n            of the link with respect to the context of the link. \n            Defaults to None.\n        mediaType (Optional[str], optional): \n            The media type of the linked resource, such as \n            \"image/jpeg\". Defaults to None.\n        name (Optional[str], optional): \n            A human-readable name for the link. Defaults to None.\n        hreflang (Optional[str], optional): \n            The language of the linked resource, represented \n            as a language tag. Defaults to None.\n        height (Optional[int], optional): \n            The height of the linked resource in pixels. \n            Must be greater than or equal to 0. Defaults to None.\n        width (Optional[int], optional): \n            The width of the linked resource in pixels. \n            Must be greater than or equal to 0. Defaults to None.\n        preview (Optional[Union[\"Object\", \"Link\"]], optional): \n            A resource that provides a preview of the linked \n            content, which could be another Link or an Object. \n            Defaults to None.\n        **kwargs: \n            Additional properties that can be added to the Link \n            object, allowing for extensibility.\n\n    Raises:\n        ValueError: \n            If `href` is not a valid URI, if `height` is negative, \n            or if `width` is negative.\n\n    \"\"\"\n    if href:\n        if not re.fullmatch(r\"(%(?![0-9A-F]{2})|#.*#)\", href):\n            raise ValueError(\"href must be xsd:anyURI\")\n    if height:\n        if height &lt; 0:\n            raise ValueError(\"height must be greater than or equal to 0\")\n    if width:\n        if width &lt; 0:\n            raise ValueError(\"width must be greater than or equal to 0\")\n    ctx = kwargs.get(\"@context\")\n    self._context = merge_contexts(_context, ctx) if ctx else []\n    self.type = type\n    self.id = id\n    self.href = href\n    self.rel = rel\n    self.media_type = mediaType\n    self.name = name\n    self.hreflang = hreflang\n    self.height = height\n    self.preview = preview\n    self._extras = {}\n    for key, value in kwargs.items():\n        self._extras[key] = value\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core.Link.to_dict","title":"<code>to_dict(_extras=None, build_context=True)</code>","text":"<p>Outputs the current object as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_extras</code> <code>Optional[dict]</code> <p>Arguments used internally. It is not recommended that users change them.</p> <code>None</code> <code>build_context</code> <code>bool</code> <p>Do we automatically build @context based on the arguments? Defaults to False.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Objects converted to dictionaries</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def to_dict(self, _extras: Optional[dict] = None, build_context: bool = True):\n    \"\"\"Outputs the current object as a dictionary.\n\n    Args:\n        _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n        build_context (bool): Do we automatically build @context based on the arguments? Defaults to False.\n\n    Returns:\n        dict: Objects converted to dictionaries\n    \"\"\"\n    if not _extras:\n        _extras = self._extras.copy()\n    instance_vars = vars(self).copy()\n\n    ctx = self._context.copy()\n    context = instance_vars.get(\"@context\")\n\n    if build_context:\n        attrs = dir(self)\n\n        ctx2 = []\n        ctx2_d = {}\n        if _extras.get(\"publicKey\") or \"publicKey\" in attrs:\n            ctx2.append(\"https://w3id.org/security/v1\")\n\n        # Mastodon\n        if _extras.get(\"featured\") or \"featured\" in attrs:\n            ctx2_d[\"featured\"] = {\n                \"@id\": \"http://joinmastodon.org/ns#featured\",\n                \"@type\": \"@id\",\n            }\n        if _extras.get(\"featuredTags\") or \"featuredTags\" in attrs:\n            ctx2_d[\"featuredTags\"] = {\n                \"@id\": \"http://joinmastodon.org/ns#featuredTags\",\n                \"@type\": \"@id\",\n            }\n        if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n            if not ctx2_d.get(\"toot\"):\n                ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n            ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n        if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n            if not ctx2_d.get(\"toot\"):\n                ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n            ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n        if (\n            _extras.get(\"manuallyApprovesFollowers\")\n            or \"manuallyApprovesFollowers\" in attrs\n        ):\n            ctx2_d[\"manuallyApprovesFollowers\"] = \"as:manuallyApprovesFollowers\"\n\n        # Misskey\n        if (\n            _extras.get(\"_misskey_content\")\n            or _extras.get(\"_misskey_summary\")\n            or _extras.get(\"_misskey_quote\")\n            or _extras.get(\"_misskey_reaction\")\n            or _extras.get(\"_misskey_votes\")\n            or _extras.get(\"_misskey_talk\")\n            or _extras.get(\"isCat\")\n            or _extras.get(\"_misskey_followedMessage\")\n            or _extras.get(\"_misskey_requireSigninToViewContents\")\n            or _extras.get(\"_misskey_makeNotesFollowersOnlyBefore\")\n            or _extras.get(\"_misskey_makeNotesHiddenBefore\")\n            or _extras.get(\"_misskey_license\")\n        ):\n            if not ctx2_d.get(\"misskey\"):\n                ctx2_d[\"misskey\"] = \"https://misskey-hub-net/ns#\"\n\n        ctx2.append(ctx2_d)\n    if context:\n        context = merge_contexts(merge_contexts(ctx, context), ctx2)\n    else:\n        context = ctx\n    data: Dict[str, Any] = {\n        \"@context\": context,\n    }\n    for key, value in instance_vars.items():\n        if value is not None:\n            if not key.startswith(\"_\") and key != \"content\":\n                if isinstance(value, datetime.datetime.datetime):\n                    data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                elif isinstance(value, Object):\n                    data[key] = value.to_dict(_extras=value._extras)\n                elif isinstance(value, list):\n                    data[key] = [\n                        item.to_dict(_extras=item._extras)\n                        if hasattr(item, \"to_dict\")\n                        else item\n                        for item in value\n                    ]\n                elif (\n                    isinstance(value, dict)\n                    or isinstance(value, int)\n                    or isinstance(value, bool)\n                ):\n                    data[key] = value\n                else:\n                    data[key] = str(value)\n\n    _extras = _extras or {}\n    for key, value in self._extras.items():\n        if value is not None:\n            if isinstance(value, datetime.datetime.datetime):\n                data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n            elif isinstance(value, Object):\n                data[key] = value.to_dict(_extras=value._extras)\n            elif isinstance(value, list):\n                data[key] = [\n                    item.to_dict(_extras=item._extras)\n                    if hasattr(item, \"to_dict\")\n                    else item\n                    for item in value\n                ]\n            elif (\n                isinstance(value, dict)\n                or isinstance(value, int)\n                or isinstance(value, bool)\n            ):\n                data[key] = value\n            else:\n                data[key] = str(value)\n    return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core.Object","title":"<code>Object</code>","text":"Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>class Object:\n    def __init__(\n        self,\n        _context: Union[str, list] = \"https://www.w3.org/ns/activitystreams\",\n        type: str = \"Object\",\n        id: Optional[str] = None,\n        attachment: List[Union[\"Object\", \"Link\", dict]] = [],\n        attributedTo: Optional[Union[\"Object\", \"Link\", str]] = None,\n        audience: Optional[Union[\"Object\", \"Link\"]] = None,\n        content: Optional[str] = None,\n        context: Optional[Union[\"Object\", \"Link\"]] = None,\n        name: Optional[str] = None,\n        endTime: Optional[str] = None,\n        generator: Optional[Union[\"Object\", \"Link\"]] = None,\n        icon: Optional[Union[\"Image\", \"Link\"]] = None,\n        image: Optional[\"Image\"] = None,\n        inReplyTo: Optional[Union[\"Image\", \"Link\"]] = None,\n        location: Optional[Union[\"Image\", \"Link\"]] = None,\n        preview: Optional[Union[\"Object\", \"Link\"]] = None,\n        published: Optional[str] = None,\n        replies: Optional[\"Collection\"] = None,\n        startTime: Optional[str] = None,\n        summary: Optional[str] = None,\n        tag: Optional[Union[\"Object\", \"Link\"]] = None,\n        updated: Optional[str] = None,\n        url: Optional[Union[str, \"Link\"]] = None,\n        to: Optional[Union[\"Object\", \"Link\"]] = None,\n        bto: Optional[Union[\"Object\", \"Link\"]] = None,\n        cc: Optional[Union[\"Object\", \"Link\"]] = None,\n        bcc: Optional[Union[\"Object\", \"Link\"]] = None,\n        mediaType: Optional[str] = None,\n        duration: Optional[str] = None,\n        sensitive: Optional[bool] = None,\n        **kwargs,\n    ):\n        \"\"\"Implements the \"Object\" primary base type of the ActivityStreams vocabulary.\n\n        Args:\n            _context (Union[str, list], optional): \n                The default value for @context. Defaults to \"https://www.w3.org/ns/activitystreams\".\n            type (str, optional): \n                The name of the ActivityStreams type. Usually does not need to be changed. Defaults to \"Object\".\n            id (Optional[str], optional): \n                The identifier for the object. Defaults to None.\n            attachment (List[Union[\"Object\", \"Link\", dict]], optional): \n                A list of resources attached to the object. Defaults to an empty list.\n            attributedTo (Optional[Union[\"Object\", \"Link\", str]], optional): \n                The resource indicating the creator of this object. Defaults to None.\n            audience (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating the intended audience of this object. Defaults to None.\n            content (Optional[str], optional): \n                The text representing the content of the object. Defaults to None.\n            context (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating the context of the object. Defaults to None.\n            name (Optional[str], optional): \n                The name of the object. Defaults to None.\n            endTime (Optional[str], optional): \n                The end time of the event represented as an ISO8601 formatted string. Defaults to None.\n            generator (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating the application that generated the object. Defaults to None.\n            icon (Optional[Union[\"Image\", \"Link\"]], optional): \n                The resource for the icon of the object. Defaults to None.\n            image (Optional[\"Image\"], optional): \n                The resource for the image of the object. Defaults to None.\n            inReplyTo (Optional[Union[\"Image\", \"Link\"]], optional): \n                The resource indicating the target of this reply. Defaults to None.\n            location (Optional[Union[\"Image\", \"Link\"]], optional): \n                The resource indicating the location of the object. Defaults to None.\n            preview (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource for the preview of the object. Defaults to None.\n            published (Optional[str], optional): \n                The date and time when the object was published, represented as an ISO8601 formatted string. Defaults to None.\n            replies (Optional[\"Collection\"], optional): \n                A collection of replies to this object. Defaults to None.\n            startTime (Optional[str], optional): \n                The start time of the event represented as an ISO8601 formatted string. Defaults to None.\n            summary (Optional[str], optional): \n                A summary of the object. Defaults to None.\n            tag (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating tags related to the object. Defaults to None.\n            updated (Optional[str], optional): \n                The date and time when the object was last updated, represented as an ISO8601 formatted string. Defaults to None.\n            url (Optional[Union[str, \"Link\"]], optional): \n                The URL of the object. Defaults to None.\n            to (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating the recipient of the object. Defaults to None.\n            bto (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating BCC recipients. Defaults to None.\n            cc (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating CC recipients. Defaults to None.\n            bcc (Optional[Union[\"Object\", \"Link\"]], optional): \n                The resource indicating BCC recipients. Defaults to None.\n            mediaType (Optional[str], optional): \n                The media type of the object. Defaults to None.\n            duration (Optional[str], optional): \n                A string representing the duration of the object. Defaults to None.\n            sensitive (Optional[bool], optional): \n                A flag indicating the sensitivity of the content. Defaults to None.\n\n        \"\"\"\n        from .loader import load\n\n        ctx = kwargs.get(\"@context\")\n        self._context = merge_contexts(_context, ctx) if ctx else []\n        self.type = type\n        self.id = id\n        self.attachment = [\n            load(attach) if isinstance(attach, dict) else attach\n            for attach in attachment\n        ]\n        self.attributedTo = (\n            load(attributedTo)\n            if isinstance(attributedTo, dict)\n            else attributedTo\n        )\n        self.audience = (\n            load(audience) if isinstance(audience, dict) else audience\n        )\n        self.content = content\n        self.context = (\n            load(context) if isinstance(context, dict) else context\n        )\n        self.name = name\n        self.endTime = (\n            (\n                endTime\n                if isinstance(endTime, datetime.datetime.datetime)\n                else datetime.datetime.datetime.strptime(\n                    endTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n                )\n            )\n            if endTime\n            else endTime\n        )\n        self.generator = (\n            load(generator) if isinstance(generator, dict) else generator\n        )\n        self.icon = load(icon) if isinstance(icon, dict) else icon\n        self.image = image\n        self.inReplyTo = (\n            load(inReplyTo) if isinstance(inReplyTo, dict) else inReplyTo\n        )\n        self.location = (\n            load(location) if isinstance(location, dict) else location\n        )\n        self.preview = (\n            load(preview) if isinstance(preview, dict) else preview\n        )\n        if published:\n            self.published = (\n                (\n                    published\n                    if isinstance(published, datetime.datetime.datetime)\n                    else datetime.datetime.datetime.strptime(\n                        published, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n                    )\n                )\n                if published\n                else published\n            )\n        else:\n            self.published = datetime.utcnow()\n        self.replies = (\n            load(replies) if isinstance(replies, dict) else replies\n        )\n        self.startTime = (\n            (\n                startTime\n                if isinstance(startTime, datetime.datetime.datetime)\n                else datetime.datetime.datetime.strptime(\n                    startTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n                )\n            )\n            if startTime\n            else startTime\n        )\n        self.summary = summary\n        self.tag = load(tag) if isinstance(tag, dict) else tag\n        self.updated = updated\n        self.url = load(url) if isinstance(url, dict) else url\n        self.to = load(to) if isinstance(to, dict) else to\n        self.bto = load(bto) if isinstance(bto, dict) else bto\n        self.cc = load(cc) if isinstance(cc, dict) else cc\n        self.bcc = load(bcc) if isinstance(bcc, dict) else bcc\n        self.mediaType = mediaType\n        self.duration = duration\n\n        # --- Extend Value\n        self.sensitive = sensitive\n        # ---\n\n        self._extras = {}\n        for key, value in kwargs.items():\n            self._extras[key] = value\n\n    def to_dict(self, _extras: Optional[dict] = None, build_context: bool = True):\n        \"\"\"Outputs the current object as a dictionary.\n\n        Args:\n            _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n            build_context (bool): Do we automatically build @context based on the arguments? Defaults to True.\n\n        Returns:\n            dict: Objects converted to dictionaries\n        \"\"\"\n        if not _extras:\n            _extras = self._extras.copy()\n        instance_vars = vars(self).copy()\n\n        ctx = self._context.copy()\n        if build_context:\n            attrs = dir(self)\n\n            ctx2 = []\n            ctx2_d = {}\n            if _extras.get(\"publicKey\") or \"publicKey\" in attrs:\n                ctx2.append(\"https://w3id.org/security/v1\")\n\n            # Mastodon\n            if _extras.get(\"featured\") or \"featured\" in attrs:\n                ctx2_d[\"featured\"] = {\n                    \"@id\": \"http://joinmastodon.org/ns#featured\",\n                    \"@type\": \"@id\",\n                }\n            if _extras.get(\"featuredTags\") or \"featuredTags\" in attrs:\n                ctx2_d[\"featuredTags\"] = {\n                    \"@id\": \"http://joinmastodon.org/ns#featuredTags\",\n                    \"@type\": \"@id\",\n                }\n            if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n                if not ctx2_d.get(\"toot\"):\n                    ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n                ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n            if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n                if not ctx2_d.get(\"toot\"):\n                    ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n                ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n            if (\n                _extras.get(\"manuallyApprovesFollowers\")\n                or \"manuallyApprovesFollowers\" in attrs\n            ):\n                ctx2_d[\"manuallyApprovesFollowers\"] = \"as:manuallyApprovesFollowers\"\n\n            # Misskey\n            if (\n                _extras.get(\"_misskey_content\")\n                or _extras.get(\"_misskey_summary\")\n                or _extras.get(\"_misskey_quote\")\n                or _extras.get(\"_misskey_reaction\")\n                or _extras.get(\"_misskey_votes\")\n                or _extras.get(\"_misskey_talk\")\n                or _extras.get(\"isCat\")\n                or _extras.get(\"_misskey_followedMessage\")\n                or _extras.get(\"_misskey_requireSigninToViewContents\")\n                or _extras.get(\"_misskey_makeNotesFollowersOnlyBefore\")\n                or _extras.get(\"_misskey_makeNotesHiddenBefore\")\n                or _extras.get(\"_misskey_license\")\n            ):\n                ctx2_d[\"misskey\"] = \"https://misskey-hub-net/ns#\"\n\n            ctx2.append(ctx2_d)\n\n        context: Optional[list] = instance_vars.get(\"@context\")\n        if context:\n            context = merge_contexts(merge_contexts(ctx, context), ctx2)\n        else:\n            context = ctx\n        data: Dict[str, Any] = {\n            \"@context\": context,\n        }\n\n        if self.content is not None:\n            data[\"content\"] = self.content\n\n        for key, value in instance_vars.items():\n            if value is not None:\n                if not key.startswith(\"_\") and key != \"content\":\n                    if isinstance(value, datetime.datetime.datetime):\n                        data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                    elif isinstance(value, Object):\n                        data[key] = value.to_dict(_extras=value._extras)\n                    elif isinstance(value, list):\n                        data[key] = [\n                            item.to_dict(_extras=item._extras)\n                            if hasattr(item, \"to_dict\")\n                            else item\n                            for item in value\n                        ]\n                    elif (\n                        isinstance(value, dict)\n                        or isinstance(value, int)\n                        or isinstance(value, bool)\n                    ):\n                        data[key] = value\n                    else:\n                        data[key] = str(value)\n\n        _extras = _extras or {}\n        for key, value in self._extras.items():\n            if value is not None:\n                if isinstance(value, datetime.datetime.datetime):\n                    data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                elif isinstance(value, Object):\n                    data[key] = value.to_dict(_extras=value._extras)\n                elif isinstance(value, list):\n                    data[key] = [\n                        item.to_dict(_extras=item._extras)\n                        if hasattr(item, \"to_dict\")\n                        else item\n                        for item in value\n                    ]\n                elif (\n                    isinstance(value, dict)\n                    or isinstance(value, int)\n                    or isinstance(value, bool)\n                ):\n                    data[key] = value\n                else:\n                    data[key] = str(value)\n        return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core.Object.__init__","title":"<code>__init__(_context='https://www.w3.org/ns/activitystreams', type='Object', id=None, attachment=[], attributedTo=None, audience=None, content=None, context=None, name=None, endTime=None, generator=None, icon=None, image=None, inReplyTo=None, location=None, preview=None, published=None, replies=None, startTime=None, summary=None, tag=None, updated=None, url=None, to=None, bto=None, cc=None, bcc=None, mediaType=None, duration=None, sensitive=None, **kwargs)</code>","text":"<p>Implements the \"Object\" primary base type of the ActivityStreams vocabulary.</p> <p>Parameters:</p> Name Type Description Default <code>_context</code> <code>Union[str, list]</code> <p>The default value for @context. Defaults to \"https://www.w3.org/ns/activitystreams\".</p> <code>'https://www.w3.org/ns/activitystreams'</code> <code>type</code> <code>str</code> <p>The name of the ActivityStreams type. Usually does not need to be changed. Defaults to \"Object\".</p> <code>'Object'</code> <code>id</code> <code>Optional[str]</code> <p>The identifier for the object. Defaults to None.</p> <code>None</code> <code>attachment</code> <code>List[Union[Object, Link, dict]]</code> <p>A list of resources attached to the object. Defaults to an empty list.</p> <code>[]</code> <code>attributedTo</code> <code>Optional[Union[Object, Link, str]]</code> <p>The resource indicating the creator of this object. Defaults to None.</p> <code>None</code> <code>audience</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating the intended audience of this object. Defaults to None.</p> <code>None</code> <code>content</code> <code>Optional[str]</code> <p>The text representing the content of the object. Defaults to None.</p> <code>None</code> <code>context</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating the context of the object. Defaults to None.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>The name of the object. Defaults to None.</p> <code>None</code> <code>endTime</code> <code>Optional[str]</code> <p>The end time of the event represented as an ISO8601 formatted string. Defaults to None.</p> <code>None</code> <code>generator</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating the application that generated the object. Defaults to None.</p> <code>None</code> <code>icon</code> <code>Optional[Union[Image, Link]]</code> <p>The resource for the icon of the object. Defaults to None.</p> <code>None</code> <code>image</code> <code>Optional[Image]</code> <p>The resource for the image of the object. Defaults to None.</p> <code>None</code> <code>inReplyTo</code> <code>Optional[Union[Image, Link]]</code> <p>The resource indicating the target of this reply. Defaults to None.</p> <code>None</code> <code>location</code> <code>Optional[Union[Image, Link]]</code> <p>The resource indicating the location of the object. Defaults to None.</p> <code>None</code> <code>preview</code> <code>Optional[Union[Object, Link]]</code> <p>The resource for the preview of the object. Defaults to None.</p> <code>None</code> <code>published</code> <code>Optional[str]</code> <p>The date and time when the object was published, represented as an ISO8601 formatted string. Defaults to None.</p> <code>None</code> <code>replies</code> <code>Optional[Collection]</code> <p>A collection of replies to this object. Defaults to None.</p> <code>None</code> <code>startTime</code> <code>Optional[str]</code> <p>The start time of the event represented as an ISO8601 formatted string. Defaults to None.</p> <code>None</code> <code>summary</code> <code>Optional[str]</code> <p>A summary of the object. Defaults to None.</p> <code>None</code> <code>tag</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating tags related to the object. Defaults to None.</p> <code>None</code> <code>updated</code> <code>Optional[str]</code> <p>The date and time when the object was last updated, represented as an ISO8601 formatted string. Defaults to None.</p> <code>None</code> <code>url</code> <code>Optional[Union[str, Link]]</code> <p>The URL of the object. Defaults to None.</p> <code>None</code> <code>to</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating the recipient of the object. Defaults to None.</p> <code>None</code> <code>bto</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating BCC recipients. Defaults to None.</p> <code>None</code> <code>cc</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating CC recipients. Defaults to None.</p> <code>None</code> <code>bcc</code> <code>Optional[Union[Object, Link]]</code> <p>The resource indicating BCC recipients. Defaults to None.</p> <code>None</code> <code>mediaType</code> <code>Optional[str]</code> <p>The media type of the object. Defaults to None.</p> <code>None</code> <code>duration</code> <code>Optional[str]</code> <p>A string representing the duration of the object. Defaults to None.</p> <code>None</code> <code>sensitive</code> <code>Optional[bool]</code> <p>A flag indicating the sensitivity of the content. Defaults to None.</p> <code>None</code> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def __init__(\n    self,\n    _context: Union[str, list] = \"https://www.w3.org/ns/activitystreams\",\n    type: str = \"Object\",\n    id: Optional[str] = None,\n    attachment: List[Union[\"Object\", \"Link\", dict]] = [],\n    attributedTo: Optional[Union[\"Object\", \"Link\", str]] = None,\n    audience: Optional[Union[\"Object\", \"Link\"]] = None,\n    content: Optional[str] = None,\n    context: Optional[Union[\"Object\", \"Link\"]] = None,\n    name: Optional[str] = None,\n    endTime: Optional[str] = None,\n    generator: Optional[Union[\"Object\", \"Link\"]] = None,\n    icon: Optional[Union[\"Image\", \"Link\"]] = None,\n    image: Optional[\"Image\"] = None,\n    inReplyTo: Optional[Union[\"Image\", \"Link\"]] = None,\n    location: Optional[Union[\"Image\", \"Link\"]] = None,\n    preview: Optional[Union[\"Object\", \"Link\"]] = None,\n    published: Optional[str] = None,\n    replies: Optional[\"Collection\"] = None,\n    startTime: Optional[str] = None,\n    summary: Optional[str] = None,\n    tag: Optional[Union[\"Object\", \"Link\"]] = None,\n    updated: Optional[str] = None,\n    url: Optional[Union[str, \"Link\"]] = None,\n    to: Optional[Union[\"Object\", \"Link\"]] = None,\n    bto: Optional[Union[\"Object\", \"Link\"]] = None,\n    cc: Optional[Union[\"Object\", \"Link\"]] = None,\n    bcc: Optional[Union[\"Object\", \"Link\"]] = None,\n    mediaType: Optional[str] = None,\n    duration: Optional[str] = None,\n    sensitive: Optional[bool] = None,\n    **kwargs,\n):\n    \"\"\"Implements the \"Object\" primary base type of the ActivityStreams vocabulary.\n\n    Args:\n        _context (Union[str, list], optional): \n            The default value for @context. Defaults to \"https://www.w3.org/ns/activitystreams\".\n        type (str, optional): \n            The name of the ActivityStreams type. Usually does not need to be changed. Defaults to \"Object\".\n        id (Optional[str], optional): \n            The identifier for the object. Defaults to None.\n        attachment (List[Union[\"Object\", \"Link\", dict]], optional): \n            A list of resources attached to the object. Defaults to an empty list.\n        attributedTo (Optional[Union[\"Object\", \"Link\", str]], optional): \n            The resource indicating the creator of this object. Defaults to None.\n        audience (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating the intended audience of this object. Defaults to None.\n        content (Optional[str], optional): \n            The text representing the content of the object. Defaults to None.\n        context (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating the context of the object. Defaults to None.\n        name (Optional[str], optional): \n            The name of the object. Defaults to None.\n        endTime (Optional[str], optional): \n            The end time of the event represented as an ISO8601 formatted string. Defaults to None.\n        generator (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating the application that generated the object. Defaults to None.\n        icon (Optional[Union[\"Image\", \"Link\"]], optional): \n            The resource for the icon of the object. Defaults to None.\n        image (Optional[\"Image\"], optional): \n            The resource for the image of the object. Defaults to None.\n        inReplyTo (Optional[Union[\"Image\", \"Link\"]], optional): \n            The resource indicating the target of this reply. Defaults to None.\n        location (Optional[Union[\"Image\", \"Link\"]], optional): \n            The resource indicating the location of the object. Defaults to None.\n        preview (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource for the preview of the object. Defaults to None.\n        published (Optional[str], optional): \n            The date and time when the object was published, represented as an ISO8601 formatted string. Defaults to None.\n        replies (Optional[\"Collection\"], optional): \n            A collection of replies to this object. Defaults to None.\n        startTime (Optional[str], optional): \n            The start time of the event represented as an ISO8601 formatted string. Defaults to None.\n        summary (Optional[str], optional): \n            A summary of the object. Defaults to None.\n        tag (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating tags related to the object. Defaults to None.\n        updated (Optional[str], optional): \n            The date and time when the object was last updated, represented as an ISO8601 formatted string. Defaults to None.\n        url (Optional[Union[str, \"Link\"]], optional): \n            The URL of the object. Defaults to None.\n        to (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating the recipient of the object. Defaults to None.\n        bto (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating BCC recipients. Defaults to None.\n        cc (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating CC recipients. Defaults to None.\n        bcc (Optional[Union[\"Object\", \"Link\"]], optional): \n            The resource indicating BCC recipients. Defaults to None.\n        mediaType (Optional[str], optional): \n            The media type of the object. Defaults to None.\n        duration (Optional[str], optional): \n            A string representing the duration of the object. Defaults to None.\n        sensitive (Optional[bool], optional): \n            A flag indicating the sensitivity of the content. Defaults to None.\n\n    \"\"\"\n    from .loader import load\n\n    ctx = kwargs.get(\"@context\")\n    self._context = merge_contexts(_context, ctx) if ctx else []\n    self.type = type\n    self.id = id\n    self.attachment = [\n        load(attach) if isinstance(attach, dict) else attach\n        for attach in attachment\n    ]\n    self.attributedTo = (\n        load(attributedTo)\n        if isinstance(attributedTo, dict)\n        else attributedTo\n    )\n    self.audience = (\n        load(audience) if isinstance(audience, dict) else audience\n    )\n    self.content = content\n    self.context = (\n        load(context) if isinstance(context, dict) else context\n    )\n    self.name = name\n    self.endTime = (\n        (\n            endTime\n            if isinstance(endTime, datetime.datetime.datetime)\n            else datetime.datetime.datetime.strptime(\n                endTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n            )\n        )\n        if endTime\n        else endTime\n    )\n    self.generator = (\n        load(generator) if isinstance(generator, dict) else generator\n    )\n    self.icon = load(icon) if isinstance(icon, dict) else icon\n    self.image = image\n    self.inReplyTo = (\n        load(inReplyTo) if isinstance(inReplyTo, dict) else inReplyTo\n    )\n    self.location = (\n        load(location) if isinstance(location, dict) else location\n    )\n    self.preview = (\n        load(preview) if isinstance(preview, dict) else preview\n    )\n    if published:\n        self.published = (\n            (\n                published\n                if isinstance(published, datetime.datetime.datetime)\n                else datetime.datetime.datetime.strptime(\n                    published, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n                )\n            )\n            if published\n            else published\n        )\n    else:\n        self.published = datetime.utcnow()\n    self.replies = (\n        load(replies) if isinstance(replies, dict) else replies\n    )\n    self.startTime = (\n        (\n            startTime\n            if isinstance(startTime, datetime.datetime.datetime)\n            else datetime.datetime.datetime.strptime(\n                startTime, \"%Y-%m-%dT%H:%M:%S.%fZ\"\n            )\n        )\n        if startTime\n        else startTime\n    )\n    self.summary = summary\n    self.tag = load(tag) if isinstance(tag, dict) else tag\n    self.updated = updated\n    self.url = load(url) if isinstance(url, dict) else url\n    self.to = load(to) if isinstance(to, dict) else to\n    self.bto = load(bto) if isinstance(bto, dict) else bto\n    self.cc = load(cc) if isinstance(cc, dict) else cc\n    self.bcc = load(bcc) if isinstance(bcc, dict) else bcc\n    self.mediaType = mediaType\n    self.duration = duration\n\n    # --- Extend Value\n    self.sensitive = sensitive\n    # ---\n\n    self._extras = {}\n    for key, value in kwargs.items():\n        self._extras[key] = value\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.core.Object.to_dict","title":"<code>to_dict(_extras=None, build_context=True)</code>","text":"<p>Outputs the current object as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>_extras</code> <code>Optional[dict]</code> <p>Arguments used internally. It is not recommended that users change them.</p> <code>None</code> <code>build_context</code> <code>bool</code> <p>Do we automatically build @context based on the arguments? Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Objects converted to dictionaries</p> Source code in <code>libs/apmodel/src/apmodel/core.py</code> <pre><code>def to_dict(self, _extras: Optional[dict] = None, build_context: bool = True):\n    \"\"\"Outputs the current object as a dictionary.\n\n    Args:\n        _extras (Optional[dict], optional): Arguments used internally. It is not recommended that users change them.\n        build_context (bool): Do we automatically build @context based on the arguments? Defaults to True.\n\n    Returns:\n        dict: Objects converted to dictionaries\n    \"\"\"\n    if not _extras:\n        _extras = self._extras.copy()\n    instance_vars = vars(self).copy()\n\n    ctx = self._context.copy()\n    if build_context:\n        attrs = dir(self)\n\n        ctx2 = []\n        ctx2_d = {}\n        if _extras.get(\"publicKey\") or \"publicKey\" in attrs:\n            ctx2.append(\"https://w3id.org/security/v1\")\n\n        # Mastodon\n        if _extras.get(\"featured\") or \"featured\" in attrs:\n            ctx2_d[\"featured\"] = {\n                \"@id\": \"http://joinmastodon.org/ns#featured\",\n                \"@type\": \"@id\",\n            }\n        if _extras.get(\"featuredTags\") or \"featuredTags\" in attrs:\n            ctx2_d[\"featuredTags\"] = {\n                \"@id\": \"http://joinmastodon.org/ns#featuredTags\",\n                \"@type\": \"@id\",\n            }\n        if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n            if not ctx2_d.get(\"toot\"):\n                ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n            ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n        if _extras.get(\"discoverable\") or \"discoverable\" in attrs:\n            if not ctx2_d.get(\"toot\"):\n                ctx2_d[\"toot\"] = \"http://joinmastodon.org/ns#\"\n            ctx2_d[\"discoverable\"] = \"toot:discoverable\"\n        if (\n            _extras.get(\"manuallyApprovesFollowers\")\n            or \"manuallyApprovesFollowers\" in attrs\n        ):\n            ctx2_d[\"manuallyApprovesFollowers\"] = \"as:manuallyApprovesFollowers\"\n\n        # Misskey\n        if (\n            _extras.get(\"_misskey_content\")\n            or _extras.get(\"_misskey_summary\")\n            or _extras.get(\"_misskey_quote\")\n            or _extras.get(\"_misskey_reaction\")\n            or _extras.get(\"_misskey_votes\")\n            or _extras.get(\"_misskey_talk\")\n            or _extras.get(\"isCat\")\n            or _extras.get(\"_misskey_followedMessage\")\n            or _extras.get(\"_misskey_requireSigninToViewContents\")\n            or _extras.get(\"_misskey_makeNotesFollowersOnlyBefore\")\n            or _extras.get(\"_misskey_makeNotesHiddenBefore\")\n            or _extras.get(\"_misskey_license\")\n        ):\n            ctx2_d[\"misskey\"] = \"https://misskey-hub-net/ns#\"\n\n        ctx2.append(ctx2_d)\n\n    context: Optional[list] = instance_vars.get(\"@context\")\n    if context:\n        context = merge_contexts(merge_contexts(ctx, context), ctx2)\n    else:\n        context = ctx\n    data: Dict[str, Any] = {\n        \"@context\": context,\n    }\n\n    if self.content is not None:\n        data[\"content\"] = self.content\n\n    for key, value in instance_vars.items():\n        if value is not None:\n            if not key.startswith(\"_\") and key != \"content\":\n                if isinstance(value, datetime.datetime.datetime):\n                    data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n                elif isinstance(value, Object):\n                    data[key] = value.to_dict(_extras=value._extras)\n                elif isinstance(value, list):\n                    data[key] = [\n                        item.to_dict(_extras=item._extras)\n                        if hasattr(item, \"to_dict\")\n                        else item\n                        for item in value\n                    ]\n                elif (\n                    isinstance(value, dict)\n                    or isinstance(value, int)\n                    or isinstance(value, bool)\n                ):\n                    data[key] = value\n                else:\n                    data[key] = str(value)\n\n    _extras = _extras or {}\n    for key, value in self._extras.items():\n        if value is not None:\n            if isinstance(value, datetime.datetime.datetime):\n                data[key] = value.isoformat(timespec='microseconds').replace('+00:00', 'Z')\n            elif isinstance(value, Object):\n                data[key] = value.to_dict(_extras=value._extras)\n            elif isinstance(value, list):\n                data[key] = [\n                    item.to_dict(_extras=item._extras)\n                    if hasattr(item, \"to_dict\")\n                    else item\n                    for item in value\n                ]\n            elif (\n                isinstance(value, dict)\n                or isinstance(value, int)\n                or isinstance(value, bool)\n            ):\n                data[key] = value\n            else:\n                data[key] = str(value)\n    return data\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.loader","title":"<code>loader</code>","text":""},{"location":"references/apmodel/#apmodel.src.apmodel.loader.StreamsLoader","title":"<code>StreamsLoader</code>","text":"Source code in <code>libs/apmodel/src/apmodel/loader.py</code> <pre><code>class StreamsLoader:\n    @staticmethod\n    @deprecated(\"StreamsLoader.load is deprecated; use loader.load.\")\n    def load(\n        object: dict[Any, Any], custom_mapper: dict = fedi_mapper\n    ) -&gt; Object | Link | Any | dict:  # type: ignore\n        \"\"\"convert json object to model\n\n        Args:\n            object (dict[Any, Any]): json object\n            custom_mapper (dict, optional): Models available at the time of loading. Defaults to fedi_mapper.\n\n        Returns:\n            Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.\n        \"\"\"\n        return load(object, custom_mapper)\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.loader.StreamsLoader.load","title":"<code>load(object, custom_mapper=fedi_mapper)</code>  <code>staticmethod</code>","text":"<p>convert json object to model</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>dict[Any, Any]</code> <p>json object</p> required <code>custom_mapper</code> <code>dict</code> <p>Models available at the time of loading. Defaults to fedi_mapper.</p> <code>fedi_mapper</code> <p>Returns:</p> Type Description <code>Object | Link | Any | dict</code> <p>Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.</p> Source code in <code>libs/apmodel/src/apmodel/loader.py</code> <pre><code>@staticmethod\n@deprecated(\"StreamsLoader.load is deprecated; use loader.load.\")\ndef load(\n    object: dict[Any, Any], custom_mapper: dict = fedi_mapper\n) -&gt; Object | Link | Any | dict:  # type: ignore\n    \"\"\"convert json object to model\n\n    Args:\n        object (dict[Any, Any]): json object\n        custom_mapper (dict, optional): Models available at the time of loading. Defaults to fedi_mapper.\n\n    Returns:\n        Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.\n    \"\"\"\n    return load(object, custom_mapper)\n</code></pre>"},{"location":"references/apmodel/#apmodel.src.apmodel.loader.load","title":"<code>load(object, custom_mapper=fedi_mapper)</code>","text":"<p>convert json object to model</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>dict[Any, Any]</code> <p>json object</p> required <code>custom_mapper</code> <code>dict</code> <p>Models available at the time of loading. Defaults to fedi_mapper.</p> <code>fedi_mapper</code> <p>Returns:</p> Type Description <code>Object | Link | dict | Any</code> <p>Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.</p> Source code in <code>libs/apmodel/src/apmodel/loader.py</code> <pre><code>def load(\n    object: dict[Any, Any], custom_mapper: dict = fedi_mapper\n) -&gt; Object | Link | dict | Any:  # type: ignore\n    \"\"\"convert json object to model\n\n    Args:\n        object (dict[Any, Any]): json object\n        custom_mapper (dict, optional): Models available at the time of loading. Defaults to fedi_mapper.\n\n    Returns:\n        Object | Link | dict | Any: An object converted from json. If there is no corresponding object, the dictionary type is returned.\n    \"\"\"\n    type = object.get(\"type\")\n    cls = custom_mapper.get(type)\n    if cls:\n        return cls(**object)\n    return object\n</code></pre>"},{"location":"references/apsig/","title":"apsig API reference","text":""},{"location":"references/apsig/#apsig.src.apsig.LDSignature","title":"<code>LDSignature</code>","text":"<p>A class for signing and verifying Linked Data signatures using the RSA signature algorithm. </p> <p>Attributes:</p> Name Type Description <code>private_key</code> <code>RSAPrivateKey</code> <p>The RSA private key used for signing.</p> <code>public_key</code> <code>RSAPublicKey</code> <p>The corresponding RSA public key.</p> <p>Methods:</p> Name Description <code>sign</code> <p>dict, creator: str, private_key: rsa.RSAPrivateKey, options: dict = None, created: datetime.datetime = None) -&gt; dict: Signs the provided document using the specified RSA private key.</p> <code>verify</code> <p>dict, public_key: rsa.RSAPublicKey | str) -&gt; bool: Verifies the signature of the provided document against the given public key.</p> Source code in <code>libs/apsig/src/apsig/ld_signature.py</code> <pre><code>class LDSignature:\n    \"\"\"A class for signing and verifying Linked Data signatures using the RSA signature algorithm. \n\n    Attributes:\n        private_key (rsa.RSAPrivateKey): The RSA private key used for signing.\n        public_key (rsa.RSAPublicKey): The corresponding RSA public key.\n\n    Methods:\n        sign(doc: dict, creator: str, private_key: rsa.RSAPrivateKey, options: dict = None, created: datetime.datetime = None) -&gt; dict:\n            Signs the provided document using the specified RSA private key.\n\n        verify(doc: dict, public_key: rsa.RSAPublicKey | str) -&gt; bool:\n            Verifies the signature of the provided document against the given public key.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def __normalized_hash(self, data):\n        norm_form = jsonld.normalize(\n            data, {\"algorithm\": \"URDNA2015\", \"format\": \"application/n-quads\"}\n        )\n        digest = hashes.Hash(hashes.SHA256())\n        digest.update(norm_form.encode(\"utf8\"))\n        return digest.finalize().hex().encode(\"ascii\")\n\n    def sign(\n        self,\n        doc: dict,\n        creator: str,\n        private_key: rsa.RSAPrivateKey,\n        options: dict = None,\n        created: datetime.datetime = None,\n    ):\n        \"\"\"Signs the provided document using the specified RSA private key.\n\n        Args:\n            doc (dict): The document to be signed.\n            creator (str): The identifier of the creator of the document.\n            private_key (rsa.RSAPrivateKey): The RSA private key used for signing.\n            options (dict, optional): Additional signing options. Defaults to None.\n            created (datetime.datetime, optional): The timestamp when the signature is created. \n                Defaults to the current UTC time if not provided.\n\n        Returns:\n            dict: The signed document containing the original data and the signature.\n        \"\"\"\n        options: dict[str, str] = {\n            \"@context\": \"https://w3c-ccg.github.io/security-vocab/contexts/security-v1.jsonld\", # \"https://w3id.org/identity/v1\"\n            \"creator\": creator,\n            \"created\": created or utcnow().strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\",\n        }\n\n        to_be_signed = self.__normalized_hash(options) + self.__normalized_hash(doc)\n\n        signature = base64.b64encode(private_key.sign(\n            to_be_signed, padding.PKCS1v15(), hashes.SHA256()\n        ))\n\n        return {\n            **doc,\n            \"signature\": {\n                **options,\n                \"type\": \"RsaSignature2017\",\n                \"signatureValue\": signature.decode(\"ascii\"),\n            },\n        }\n\n    def verify(self, doc: dict, public_key: rsa.RSAPublicKey | str, raise_on_fail: bool = False) -&gt; Union[str, None]:\n        \"\"\"Verifies the signature of the provided document against the given public key.\n\n        Args:\n            doc (dict): The signed document to verify.\n            public_key (rsa.RSAPublicKey | str): The RSA public key in PEM format or as a multibase-encoded string.\n\n        Returns:\n            bool: True if the signature is valid; otherwise, an exception is raised.\n\n        Raises:\n            MissingSignature: If the signature section is missing in the document.\n            UnknownSignature: If the signature type is not recognized.\n            VerificationFailed: If the signature verification fails.\n        \"\"\"\n        if isinstance(public_key, str):\n            codec, data = multicodec.unwrap(multibase.decode(public_key))\n            if codec.name != \"rsa-pub\":\n                if raise_on_fail:\n                    raise ValueError(\"public_key must be RSA PublicKey.\")\n                return None\n            public_key = serialization.load_pem_public_key(data, backend=default_backend())\n        try:\n            document = doc.copy()\n            signature = document.pop(\"signature\")\n            options = {\n                \"@context\": \"https://w3c-ccg.github.io/security-vocab/contexts/security-v1.jsonld\",\n                \"creator\": signature[\"creator\"],\n                \"created\": signature[\"created\"],\n            }\n        except KeyError:\n            if raise_on_fail:\n                raise MissingSignature(\"Invalid signature section\")\n            return None\n        if signature[\"type\"].lower() != \"rsasignature2017\":\n            if raise_on_fail:\n                raise UnknownSignature(\"Unknown signature type\")\n            return None\n        final_hash = self.__normalized_hash(options) + self.__normalized_hash(document)\n        try:\n            public_key.verify(\n                base64.b64decode(signature[\"signatureValue\"]),\n                final_hash,\n                padding.PKCS1v15(),\n                hashes.SHA256(),\n            )\n            return signature[\"creator\"]\n        except InvalidSignature:\n            if raise_on_fail:\n                raise VerificationFailed(\"LDSignature mismatch\")\n            return None\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.LDSignature.sign","title":"<code>sign(doc, creator, private_key, options=None, created=None)</code>","text":"<p>Signs the provided document using the specified RSA private key.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>dict</code> <p>The document to be signed.</p> required <code>creator</code> <code>str</code> <p>The identifier of the creator of the document.</p> required <code>private_key</code> <code>RSAPrivateKey</code> <p>The RSA private key used for signing.</p> required <code>options</code> <code>dict</code> <p>Additional signing options. Defaults to None.</p> <code>None</code> <code>created</code> <code>datetime</code> <p>The timestamp when the signature is created.  Defaults to the current UTC time if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The signed document containing the original data and the signature.</p> Source code in <code>libs/apsig/src/apsig/ld_signature.py</code> <pre><code>def sign(\n    self,\n    doc: dict,\n    creator: str,\n    private_key: rsa.RSAPrivateKey,\n    options: dict = None,\n    created: datetime.datetime = None,\n):\n    \"\"\"Signs the provided document using the specified RSA private key.\n\n    Args:\n        doc (dict): The document to be signed.\n        creator (str): The identifier of the creator of the document.\n        private_key (rsa.RSAPrivateKey): The RSA private key used for signing.\n        options (dict, optional): Additional signing options. Defaults to None.\n        created (datetime.datetime, optional): The timestamp when the signature is created. \n            Defaults to the current UTC time if not provided.\n\n    Returns:\n        dict: The signed document containing the original data and the signature.\n    \"\"\"\n    options: dict[str, str] = {\n        \"@context\": \"https://w3c-ccg.github.io/security-vocab/contexts/security-v1.jsonld\", # \"https://w3id.org/identity/v1\"\n        \"creator\": creator,\n        \"created\": created or utcnow().strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\",\n    }\n\n    to_be_signed = self.__normalized_hash(options) + self.__normalized_hash(doc)\n\n    signature = base64.b64encode(private_key.sign(\n        to_be_signed, padding.PKCS1v15(), hashes.SHA256()\n    ))\n\n    return {\n        **doc,\n        \"signature\": {\n            **options,\n            \"type\": \"RsaSignature2017\",\n            \"signatureValue\": signature.decode(\"ascii\"),\n        },\n    }\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.LDSignature.verify","title":"<code>verify(doc, public_key, raise_on_fail=False)</code>","text":"<p>Verifies the signature of the provided document against the given public key.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>dict</code> <p>The signed document to verify.</p> required <code>public_key</code> <code>RSAPublicKey | str</code> <p>The RSA public key in PEM format or as a multibase-encoded string.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>Union[str, None]</code> <p>True if the signature is valid; otherwise, an exception is raised.</p> <p>Raises:</p> Type Description <code>MissingSignature</code> <p>If the signature section is missing in the document.</p> <code>UnknownSignature</code> <p>If the signature type is not recognized.</p> <code>VerificationFailed</code> <p>If the signature verification fails.</p> Source code in <code>libs/apsig/src/apsig/ld_signature.py</code> <pre><code>def verify(self, doc: dict, public_key: rsa.RSAPublicKey | str, raise_on_fail: bool = False) -&gt; Union[str, None]:\n    \"\"\"Verifies the signature of the provided document against the given public key.\n\n    Args:\n        doc (dict): The signed document to verify.\n        public_key (rsa.RSAPublicKey | str): The RSA public key in PEM format or as a multibase-encoded string.\n\n    Returns:\n        bool: True if the signature is valid; otherwise, an exception is raised.\n\n    Raises:\n        MissingSignature: If the signature section is missing in the document.\n        UnknownSignature: If the signature type is not recognized.\n        VerificationFailed: If the signature verification fails.\n    \"\"\"\n    if isinstance(public_key, str):\n        codec, data = multicodec.unwrap(multibase.decode(public_key))\n        if codec.name != \"rsa-pub\":\n            if raise_on_fail:\n                raise ValueError(\"public_key must be RSA PublicKey.\")\n            return None\n        public_key = serialization.load_pem_public_key(data, backend=default_backend())\n    try:\n        document = doc.copy()\n        signature = document.pop(\"signature\")\n        options = {\n            \"@context\": \"https://w3c-ccg.github.io/security-vocab/contexts/security-v1.jsonld\",\n            \"creator\": signature[\"creator\"],\n            \"created\": signature[\"created\"],\n        }\n    except KeyError:\n        if raise_on_fail:\n            raise MissingSignature(\"Invalid signature section\")\n        return None\n    if signature[\"type\"].lower() != \"rsasignature2017\":\n        if raise_on_fail:\n            raise UnknownSignature(\"Unknown signature type\")\n        return None\n    final_hash = self.__normalized_hash(options) + self.__normalized_hash(document)\n    try:\n        public_key.verify(\n            base64.b64decode(signature[\"signatureValue\"]),\n            final_hash,\n            padding.PKCS1v15(),\n            hashes.SHA256(),\n        )\n        return signature[\"creator\"]\n    except InvalidSignature:\n        if raise_on_fail:\n            raise VerificationFailed(\"LDSignature mismatch\")\n        return None\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draftVerifier","title":"<code>draftVerifier</code>","text":"Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>class draftVerifier:\n    @staticmethod\n    @deprecated(\n        \"apsig.draft.verify.draftVerifier is deprecated; use apsig.draft.verify.Verifier instead. This will be removed in apsig 1.0.\"\n    )\n    def verify(\n        public_pem: str, method: str, url: str, headers: dict, body: bytes = b\"\"\n    ) -&gt; tuple[bool, str]:\n        \"\"\"Verifies the digital signature of an HTTP request.\n\n        Args:\n            public_pem (str): The public key in PEM format used to verify the signature.\n            method (str): The HTTP method (e.g., \"GET\", \"POST\").\n            url (str): The URL of the request.\n            headers (dict): A dictionary of HTTP headers, including the signature and other relevant information.\n            body (bytes, optional): The request body. Defaults to an empty byte string.\n\n        Returns:\n            tuple: A tuple containing:\n                - bool: True if the signature is valid, False otherwise.\n                - str: A message indicating the result of the verification.\n\n        Raises:\n            ValueError: If the signature header is missing or if the algorithm is unsupported.\n        \"\"\"\n        try:\n            result = Verifier(\n                public_pem=public_pem, method=method, url=url, headers=headers, body=body\n            ).verify(raise_on_fail=True)\n        except Exception as e:\n            return False, str(e)\n        if result:\n            return True, \"Signature is valid\"\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draftVerifier.verify","title":"<code>verify(public_pem, method, url, headers, body=b'')</code>  <code>staticmethod</code>","text":"<p>Verifies the digital signature of an HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>public_pem</code> <code>str</code> <p>The public key in PEM format used to verify the signature.</p> required <code>method</code> <code>str</code> <p>The HTTP method (e.g., \"GET\", \"POST\").</p> required <code>url</code> <code>str</code> <p>The URL of the request.</p> required <code>headers</code> <code>dict</code> <p>A dictionary of HTTP headers, including the signature and other relevant information.</p> required <code>body</code> <code>bytes</code> <p>The request body. Defaults to an empty byte string.</p> <code>b''</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[bool, str]</code> <p>A tuple containing: - bool: True if the signature is valid, False otherwise. - str: A message indicating the result of the verification.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature header is missing or if the algorithm is unsupported.</p> Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>@staticmethod\n@deprecated(\n    \"apsig.draft.verify.draftVerifier is deprecated; use apsig.draft.verify.Verifier instead. This will be removed in apsig 1.0.\"\n)\ndef verify(\n    public_pem: str, method: str, url: str, headers: dict, body: bytes = b\"\"\n) -&gt; tuple[bool, str]:\n    \"\"\"Verifies the digital signature of an HTTP request.\n\n    Args:\n        public_pem (str): The public key in PEM format used to verify the signature.\n        method (str): The HTTP method (e.g., \"GET\", \"POST\").\n        url (str): The URL of the request.\n        headers (dict): A dictionary of HTTP headers, including the signature and other relevant information.\n        body (bytes, optional): The request body. Defaults to an empty byte string.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if the signature is valid, False otherwise.\n            - str: A message indicating the result of the verification.\n\n    Raises:\n        ValueError: If the signature header is missing or if the algorithm is unsupported.\n    \"\"\"\n    try:\n        result = Verifier(\n            public_pem=public_pem, method=method, url=url, headers=headers, body=body\n        ).verify(raise_on_fail=True)\n    except Exception as e:\n        return False, str(e)\n    if result:\n        return True, \"Signature is valid\"\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft","title":"<code>draft</code>","text":""},{"location":"references/apsig/#apsig.src.apsig.draft.Signer","title":"<code>Signer</code>","text":"Source code in <code>libs/apsig/src/apsig/draft/sign.py</code> <pre><code>class Signer:\n    def __init__(self, headers: dict[Any, Any], private_key: rsa.RSAPrivateKey, method: str, url: str, key_id: str, body: bytes=b\"\") -&gt; None:\n        \"\"\"Signs an HTTP request with a digital signature.\n\n        Args:\n            private_key (rsa.RSAPrivateKey): The RSA private key used to sign the request.\n            method (str): The HTTP method (e.g., \"GET\", \"POST\").\n            url (str): The URL of the request.\n            headers (dict): A dictionary of HTTP headers that will be signed.\n            key_id (str): The key identifier to include in the signature header.\n            body (bytes, optional): The request body. Defaults to an empty byte string.\n\n        Returns:\n            dict: The HTTP headers with the signature added.\n\n        Raises:\n            ValueError: If the signing process fails due to invalid parameters.\n        \"\"\"\n        if not headers.get(\"date\") and not headers.get(\"Date\"):\n            headers[\"date\"] = email.utils.formatdate(usegmt=True)\n        self.parsed_url: ParseResult = urlparse(url)\n        self.headers = {\n            **headers,\n            \"(request-target)\": f\"{method.lower()} {self.parsed_url.path}\"\n        }\n        self.private_key = private_key\n        self.method = method\n        self.url = url\n        self.key_id = key_id\n        self.body = body\n\n        if not self.headers.get(\"Host\"):\n            self.headers[\"Host\"] = self.parsed_url.netloc\n\n        self.__generate_digest(self.body)\n\n    def __generate_sign_header(self, signature: str):\n        self.headers[\"Signature\"] = signature\n        self.headers[\"Authorization\"] = f\"Signature {signature}\"\n\n    def __sign_document(self, document: bytes):\n        return base64.standard_b64encode(self.private_key.sign(document, padding.PKCS1v15(), hashes.SHA256())).decode(\"utf-8\")\n\n    def __generate_digest(self, body: bytes | str):\n        if not self.headers.get(\"digest\") and not self.headers.get(\"Digest\"):\n            self.headers[\"digest\"] = calculate_digest(body)\n        else:\n            return self.headers.get(\"digest\")\n\n    def build_signature(self, key_id: str, signature: str, algorithm: str = \"rsa-sha256\"):\n        if algorithm != \"rsa-sha256\":\n            raise NotImplementedError(f\"Unsuppored algorithm: {algorithm}\")\n\n        return \",\".join([\n            f'keyId=\"{key_id}\"',\n            f'algorithm=\"{algorithm}\"',\n            f'headers=\"{\" \".join(key.lower() for key in self.headers.keys())}\"',\n            f'signature=\"{signature}\"'\n        ])\n\n    def sign(self) -&gt; dict:\n        signature_string = build_string(self.headers).encode(\"utf-8\")\n        signature = self.__sign_document(signature_string)\n        signed = self.build_signature(self.key_id, signature)\n        self.__generate_sign_header(signed)\n\n        headers = self.headers.copy()\n        headers.pop(\"(request-target)\")\n\n        return headers\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.Signer.__init__","title":"<code>__init__(headers, private_key, method, url, key_id, body=b'')</code>","text":"<p>Signs an HTTP request with a digital signature.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>RSAPrivateKey</code> <p>The RSA private key used to sign the request.</p> required <code>method</code> <code>str</code> <p>The HTTP method (e.g., \"GET\", \"POST\").</p> required <code>url</code> <code>str</code> <p>The URL of the request.</p> required <code>headers</code> <code>dict</code> <p>A dictionary of HTTP headers that will be signed.</p> required <code>key_id</code> <code>str</code> <p>The key identifier to include in the signature header.</p> required <code>body</code> <code>bytes</code> <p>The request body. Defaults to an empty byte string.</p> <code>b''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>None</code> <p>The HTTP headers with the signature added.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signing process fails due to invalid parameters.</p> Source code in <code>libs/apsig/src/apsig/draft/sign.py</code> <pre><code>def __init__(self, headers: dict[Any, Any], private_key: rsa.RSAPrivateKey, method: str, url: str, key_id: str, body: bytes=b\"\") -&gt; None:\n    \"\"\"Signs an HTTP request with a digital signature.\n\n    Args:\n        private_key (rsa.RSAPrivateKey): The RSA private key used to sign the request.\n        method (str): The HTTP method (e.g., \"GET\", \"POST\").\n        url (str): The URL of the request.\n        headers (dict): A dictionary of HTTP headers that will be signed.\n        key_id (str): The key identifier to include in the signature header.\n        body (bytes, optional): The request body. Defaults to an empty byte string.\n\n    Returns:\n        dict: The HTTP headers with the signature added.\n\n    Raises:\n        ValueError: If the signing process fails due to invalid parameters.\n    \"\"\"\n    if not headers.get(\"date\") and not headers.get(\"Date\"):\n        headers[\"date\"] = email.utils.formatdate(usegmt=True)\n    self.parsed_url: ParseResult = urlparse(url)\n    self.headers = {\n        **headers,\n        \"(request-target)\": f\"{method.lower()} {self.parsed_url.path}\"\n    }\n    self.private_key = private_key\n    self.method = method\n    self.url = url\n    self.key_id = key_id\n    self.body = body\n\n    if not self.headers.get(\"Host\"):\n        self.headers[\"Host\"] = self.parsed_url.netloc\n\n    self.__generate_digest(self.body)\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.Verifier","title":"<code>Verifier</code>","text":"Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>class Verifier:\n    def __init__(\n        self, public_pem: str, method: str, url: str, headers: dict, body: bytes = b\"\"\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            public_pem (str): The public key in PEM format used to verify the signature.\n            method (str): The HTTP method (e.g., \"GET\", \"POST\").\n            url (str): The URL of the request.\n            headers (dict): A dictionary of HTTP headers, including the signature and other relevant information.\n            body (bytes, optional): The request body. Defaults to an empty byte string.\n        \"\"\"\n        self.public_pem = public_pem\n        self.method = method\n        self.url = url\n        self.headers_raw = headers\n        self.headers = {key.lower(): value for key, value in headers.items()}\n        self.body = body\n\n    def __decode_sign(self, signature):\n        return base64.standard_b64decode(signature)\n\n    def verify(self, raise_on_fail: bool = False) -&gt; Union[str, None]:\n        \"\"\"Verifies the digital signature of an HTTP request.\n\n        Args:\n            raise_on_fail (bool, optional): Return error on failure. defaults to False.\n\n        Returns:\n\n        Raises:\n            ValueError: If the signature header is missing or if the algorithm is unsupported.\n        \"\"\"\n        headers = self.headers.copy()\n\n        signature_header = headers.get(\"signature\")\n        if not signature_header:\n            if raise_on_fail:\n                raise MissingSignature(\n                    \"Signature header is missing\"\n                )\n            return None\n\n        signature_parts = {}\n        for item in signature_header.split(\",\"):\n            key, value = item.split(\"=\", 1)\n            signature_parts[key.strip()] = value.strip().strip('\"')\n\n        signature = self.__decode_sign(signature_parts[\"signature\"])\n        key_id = signature_parts[\"keyId\"]\n        algorithm = signature_parts[\"algorithm\"]\n\n        if algorithm != \"rsa-sha256\":\n            if raise_on_fail:\n                raise UnknownSignature(\n                    f\"Unsupported algorithm. Algorithm must be rsa-sha256, but passed {algorithm}.\"\n                )\n            return None\n\n        signed_headers = signature_parts[\"headers\"].split()\n\n        parsed_url = urlparse(self.url)\n\n        signature_headers = headers.copy()\n        signature_headers[\"(request-target)\"] = (\n            f\"{self.method.lower()} {parsed_url.path}\"\n        )\n        signature_string = build_string(\n            signature_headers, headers=signed_headers\n        ).encode(\"utf-8\")\n\n        public_key = serialization.load_pem_public_key(\n            self.public_pem.encode(\"utf-8\"), backend=default_backend()\n        )\n\n        try:\n            public_key.verify(\n                signature, signature_string, padding.PKCS1v15(), hashes.SHA256()\n            )\n        except InvalidSignature:\n            if raise_on_fail:\n                raise VerificationFailed(\n                    \"Invalid signature\"\n                )\n            return None\n\n        expected_digest = calculate_digest(self.body)\n        if headers.get(\"digest\") != expected_digest:\n            if raise_on_fail:\n                raise VerificationFailed(\n                    \"Digest mismatch\"\n                )\n            return None\n\n        date_header = headers.get(\"date\")\n        if date_header:\n            date = datetime.datetime.datetime.strptime(\n                date_header, \"%a, %d %b %Y %H:%M:%S GMT\"\n            )\n            gmt_tz = pytz.timezone('GMT')\n            gmt_time = gmt_tz.localize(date)\n            request_time = gmt_time.astimezone(pytz.utc)\n            current_time = datetime.utcnow()\n            if abs((current_time - request_time).total_seconds()) &gt; 3600:\n                if raise_on_fail:\n                    raise VerificationFailed(\n                        \"Date header is too far from current time\"\n                    )\n                return None\n\n        return key_id\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.Verifier.__init__","title":"<code>__init__(public_pem, method, url, headers, body=b'')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>public_pem</code> <code>str</code> <p>The public key in PEM format used to verify the signature.</p> required <code>method</code> <code>str</code> <p>The HTTP method (e.g., \"GET\", \"POST\").</p> required <code>url</code> <code>str</code> <p>The URL of the request.</p> required <code>headers</code> <code>dict</code> <p>A dictionary of HTTP headers, including the signature and other relevant information.</p> required <code>body</code> <code>bytes</code> <p>The request body. Defaults to an empty byte string.</p> <code>b''</code> Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>def __init__(\n    self, public_pem: str, method: str, url: str, headers: dict, body: bytes = b\"\"\n) -&gt; None:\n    \"\"\"\n    Args:\n        public_pem (str): The public key in PEM format used to verify the signature.\n        method (str): The HTTP method (e.g., \"GET\", \"POST\").\n        url (str): The URL of the request.\n        headers (dict): A dictionary of HTTP headers, including the signature and other relevant information.\n        body (bytes, optional): The request body. Defaults to an empty byte string.\n    \"\"\"\n    self.public_pem = public_pem\n    self.method = method\n    self.url = url\n    self.headers_raw = headers\n    self.headers = {key.lower(): value for key, value in headers.items()}\n    self.body = body\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.Verifier.verify","title":"<code>verify(raise_on_fail=False)</code>","text":"<p>Verifies the digital signature of an HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>raise_on_fail</code> <code>bool</code> <p>Return error on failure. defaults to False.</p> <code>False</code> <p>Returns:</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature header is missing or if the algorithm is unsupported.</p> Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>def verify(self, raise_on_fail: bool = False) -&gt; Union[str, None]:\n    \"\"\"Verifies the digital signature of an HTTP request.\n\n    Args:\n        raise_on_fail (bool, optional): Return error on failure. defaults to False.\n\n    Returns:\n\n    Raises:\n        ValueError: If the signature header is missing or if the algorithm is unsupported.\n    \"\"\"\n    headers = self.headers.copy()\n\n    signature_header = headers.get(\"signature\")\n    if not signature_header:\n        if raise_on_fail:\n            raise MissingSignature(\n                \"Signature header is missing\"\n            )\n        return None\n\n    signature_parts = {}\n    for item in signature_header.split(\",\"):\n        key, value = item.split(\"=\", 1)\n        signature_parts[key.strip()] = value.strip().strip('\"')\n\n    signature = self.__decode_sign(signature_parts[\"signature\"])\n    key_id = signature_parts[\"keyId\"]\n    algorithm = signature_parts[\"algorithm\"]\n\n    if algorithm != \"rsa-sha256\":\n        if raise_on_fail:\n            raise UnknownSignature(\n                f\"Unsupported algorithm. Algorithm must be rsa-sha256, but passed {algorithm}.\"\n            )\n        return None\n\n    signed_headers = signature_parts[\"headers\"].split()\n\n    parsed_url = urlparse(self.url)\n\n    signature_headers = headers.copy()\n    signature_headers[\"(request-target)\"] = (\n        f\"{self.method.lower()} {parsed_url.path}\"\n    )\n    signature_string = build_string(\n        signature_headers, headers=signed_headers\n    ).encode(\"utf-8\")\n\n    public_key = serialization.load_pem_public_key(\n        self.public_pem.encode(\"utf-8\"), backend=default_backend()\n    )\n\n    try:\n        public_key.verify(\n            signature, signature_string, padding.PKCS1v15(), hashes.SHA256()\n        )\n    except InvalidSignature:\n        if raise_on_fail:\n            raise VerificationFailed(\n                \"Invalid signature\"\n            )\n        return None\n\n    expected_digest = calculate_digest(self.body)\n    if headers.get(\"digest\") != expected_digest:\n        if raise_on_fail:\n            raise VerificationFailed(\n                \"Digest mismatch\"\n            )\n        return None\n\n    date_header = headers.get(\"date\")\n    if date_header:\n        date = datetime.datetime.datetime.strptime(\n            date_header, \"%a, %d %b %Y %H:%M:%S GMT\"\n        )\n        gmt_tz = pytz.timezone('GMT')\n        gmt_time = gmt_tz.localize(date)\n        request_time = gmt_time.astimezone(pytz.utc)\n        current_time = datetime.utcnow()\n        if abs((current_time - request_time).total_seconds()) &gt; 3600:\n            if raise_on_fail:\n                raise VerificationFailed(\n                    \"Date header is too far from current time\"\n                )\n            return None\n\n    return key_id\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.sign","title":"<code>sign</code>","text":""},{"location":"references/apsig/#apsig.src.apsig.draft.sign.Signer","title":"<code>Signer</code>","text":"Source code in <code>libs/apsig/src/apsig/draft/sign.py</code> <pre><code>class Signer:\n    def __init__(self, headers: dict[Any, Any], private_key: rsa.RSAPrivateKey, method: str, url: str, key_id: str, body: bytes=b\"\") -&gt; None:\n        \"\"\"Signs an HTTP request with a digital signature.\n\n        Args:\n            private_key (rsa.RSAPrivateKey): The RSA private key used to sign the request.\n            method (str): The HTTP method (e.g., \"GET\", \"POST\").\n            url (str): The URL of the request.\n            headers (dict): A dictionary of HTTP headers that will be signed.\n            key_id (str): The key identifier to include in the signature header.\n            body (bytes, optional): The request body. Defaults to an empty byte string.\n\n        Returns:\n            dict: The HTTP headers with the signature added.\n\n        Raises:\n            ValueError: If the signing process fails due to invalid parameters.\n        \"\"\"\n        if not headers.get(\"date\") and not headers.get(\"Date\"):\n            headers[\"date\"] = email.utils.formatdate(usegmt=True)\n        self.parsed_url: ParseResult = urlparse(url)\n        self.headers = {\n            **headers,\n            \"(request-target)\": f\"{method.lower()} {self.parsed_url.path}\"\n        }\n        self.private_key = private_key\n        self.method = method\n        self.url = url\n        self.key_id = key_id\n        self.body = body\n\n        if not self.headers.get(\"Host\"):\n            self.headers[\"Host\"] = self.parsed_url.netloc\n\n        self.__generate_digest(self.body)\n\n    def __generate_sign_header(self, signature: str):\n        self.headers[\"Signature\"] = signature\n        self.headers[\"Authorization\"] = f\"Signature {signature}\"\n\n    def __sign_document(self, document: bytes):\n        return base64.standard_b64encode(self.private_key.sign(document, padding.PKCS1v15(), hashes.SHA256())).decode(\"utf-8\")\n\n    def __generate_digest(self, body: bytes | str):\n        if not self.headers.get(\"digest\") and not self.headers.get(\"Digest\"):\n            self.headers[\"digest\"] = calculate_digest(body)\n        else:\n            return self.headers.get(\"digest\")\n\n    def build_signature(self, key_id: str, signature: str, algorithm: str = \"rsa-sha256\"):\n        if algorithm != \"rsa-sha256\":\n            raise NotImplementedError(f\"Unsuppored algorithm: {algorithm}\")\n\n        return \",\".join([\n            f'keyId=\"{key_id}\"',\n            f'algorithm=\"{algorithm}\"',\n            f'headers=\"{\" \".join(key.lower() for key in self.headers.keys())}\"',\n            f'signature=\"{signature}\"'\n        ])\n\n    def sign(self) -&gt; dict:\n        signature_string = build_string(self.headers).encode(\"utf-8\")\n        signature = self.__sign_document(signature_string)\n        signed = self.build_signature(self.key_id, signature)\n        self.__generate_sign_header(signed)\n\n        headers = self.headers.copy()\n        headers.pop(\"(request-target)\")\n\n        return headers\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.sign.Signer.__init__","title":"<code>__init__(headers, private_key, method, url, key_id, body=b'')</code>","text":"<p>Signs an HTTP request with a digital signature.</p> <p>Parameters:</p> Name Type Description Default <code>private_key</code> <code>RSAPrivateKey</code> <p>The RSA private key used to sign the request.</p> required <code>method</code> <code>str</code> <p>The HTTP method (e.g., \"GET\", \"POST\").</p> required <code>url</code> <code>str</code> <p>The URL of the request.</p> required <code>headers</code> <code>dict</code> <p>A dictionary of HTTP headers that will be signed.</p> required <code>key_id</code> <code>str</code> <p>The key identifier to include in the signature header.</p> required <code>body</code> <code>bytes</code> <p>The request body. Defaults to an empty byte string.</p> <code>b''</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>None</code> <p>The HTTP headers with the signature added.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signing process fails due to invalid parameters.</p> Source code in <code>libs/apsig/src/apsig/draft/sign.py</code> <pre><code>def __init__(self, headers: dict[Any, Any], private_key: rsa.RSAPrivateKey, method: str, url: str, key_id: str, body: bytes=b\"\") -&gt; None:\n    \"\"\"Signs an HTTP request with a digital signature.\n\n    Args:\n        private_key (rsa.RSAPrivateKey): The RSA private key used to sign the request.\n        method (str): The HTTP method (e.g., \"GET\", \"POST\").\n        url (str): The URL of the request.\n        headers (dict): A dictionary of HTTP headers that will be signed.\n        key_id (str): The key identifier to include in the signature header.\n        body (bytes, optional): The request body. Defaults to an empty byte string.\n\n    Returns:\n        dict: The HTTP headers with the signature added.\n\n    Raises:\n        ValueError: If the signing process fails due to invalid parameters.\n    \"\"\"\n    if not headers.get(\"date\") and not headers.get(\"Date\"):\n        headers[\"date\"] = email.utils.formatdate(usegmt=True)\n    self.parsed_url: ParseResult = urlparse(url)\n    self.headers = {\n        **headers,\n        \"(request-target)\": f\"{method.lower()} {self.parsed_url.path}\"\n    }\n    self.private_key = private_key\n    self.method = method\n    self.url = url\n    self.key_id = key_id\n    self.body = body\n\n    if not self.headers.get(\"Host\"):\n        self.headers[\"Host\"] = self.parsed_url.netloc\n\n    self.__generate_digest(self.body)\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.verify","title":"<code>verify</code>","text":""},{"location":"references/apsig/#apsig.src.apsig.draft.verify.Verifier","title":"<code>Verifier</code>","text":"Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>class Verifier:\n    def __init__(\n        self, public_pem: str, method: str, url: str, headers: dict, body: bytes = b\"\"\n    ) -&gt; None:\n        \"\"\"\n        Args:\n            public_pem (str): The public key in PEM format used to verify the signature.\n            method (str): The HTTP method (e.g., \"GET\", \"POST\").\n            url (str): The URL of the request.\n            headers (dict): A dictionary of HTTP headers, including the signature and other relevant information.\n            body (bytes, optional): The request body. Defaults to an empty byte string.\n        \"\"\"\n        self.public_pem = public_pem\n        self.method = method\n        self.url = url\n        self.headers_raw = headers\n        self.headers = {key.lower(): value for key, value in headers.items()}\n        self.body = body\n\n    def __decode_sign(self, signature):\n        return base64.standard_b64decode(signature)\n\n    def verify(self, raise_on_fail: bool = False) -&gt; Union[str, None]:\n        \"\"\"Verifies the digital signature of an HTTP request.\n\n        Args:\n            raise_on_fail (bool, optional): Return error on failure. defaults to False.\n\n        Returns:\n\n        Raises:\n            ValueError: If the signature header is missing or if the algorithm is unsupported.\n        \"\"\"\n        headers = self.headers.copy()\n\n        signature_header = headers.get(\"signature\")\n        if not signature_header:\n            if raise_on_fail:\n                raise MissingSignature(\n                    \"Signature header is missing\"\n                )\n            return None\n\n        signature_parts = {}\n        for item in signature_header.split(\",\"):\n            key, value = item.split(\"=\", 1)\n            signature_parts[key.strip()] = value.strip().strip('\"')\n\n        signature = self.__decode_sign(signature_parts[\"signature\"])\n        key_id = signature_parts[\"keyId\"]\n        algorithm = signature_parts[\"algorithm\"]\n\n        if algorithm != \"rsa-sha256\":\n            if raise_on_fail:\n                raise UnknownSignature(\n                    f\"Unsupported algorithm. Algorithm must be rsa-sha256, but passed {algorithm}.\"\n                )\n            return None\n\n        signed_headers = signature_parts[\"headers\"].split()\n\n        parsed_url = urlparse(self.url)\n\n        signature_headers = headers.copy()\n        signature_headers[\"(request-target)\"] = (\n            f\"{self.method.lower()} {parsed_url.path}\"\n        )\n        signature_string = build_string(\n            signature_headers, headers=signed_headers\n        ).encode(\"utf-8\")\n\n        public_key = serialization.load_pem_public_key(\n            self.public_pem.encode(\"utf-8\"), backend=default_backend()\n        )\n\n        try:\n            public_key.verify(\n                signature, signature_string, padding.PKCS1v15(), hashes.SHA256()\n            )\n        except InvalidSignature:\n            if raise_on_fail:\n                raise VerificationFailed(\n                    \"Invalid signature\"\n                )\n            return None\n\n        expected_digest = calculate_digest(self.body)\n        if headers.get(\"digest\") != expected_digest:\n            if raise_on_fail:\n                raise VerificationFailed(\n                    \"Digest mismatch\"\n                )\n            return None\n\n        date_header = headers.get(\"date\")\n        if date_header:\n            date = datetime.datetime.datetime.strptime(\n                date_header, \"%a, %d %b %Y %H:%M:%S GMT\"\n            )\n            gmt_tz = pytz.timezone('GMT')\n            gmt_time = gmt_tz.localize(date)\n            request_time = gmt_time.astimezone(pytz.utc)\n            current_time = datetime.utcnow()\n            if abs((current_time - request_time).total_seconds()) &gt; 3600:\n                if raise_on_fail:\n                    raise VerificationFailed(\n                        \"Date header is too far from current time\"\n                    )\n                return None\n\n        return key_id\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.verify.Verifier.__init__","title":"<code>__init__(public_pem, method, url, headers, body=b'')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>public_pem</code> <code>str</code> <p>The public key in PEM format used to verify the signature.</p> required <code>method</code> <code>str</code> <p>The HTTP method (e.g., \"GET\", \"POST\").</p> required <code>url</code> <code>str</code> <p>The URL of the request.</p> required <code>headers</code> <code>dict</code> <p>A dictionary of HTTP headers, including the signature and other relevant information.</p> required <code>body</code> <code>bytes</code> <p>The request body. Defaults to an empty byte string.</p> <code>b''</code> Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>def __init__(\n    self, public_pem: str, method: str, url: str, headers: dict, body: bytes = b\"\"\n) -&gt; None:\n    \"\"\"\n    Args:\n        public_pem (str): The public key in PEM format used to verify the signature.\n        method (str): The HTTP method (e.g., \"GET\", \"POST\").\n        url (str): The URL of the request.\n        headers (dict): A dictionary of HTTP headers, including the signature and other relevant information.\n        body (bytes, optional): The request body. Defaults to an empty byte string.\n    \"\"\"\n    self.public_pem = public_pem\n    self.method = method\n    self.url = url\n    self.headers_raw = headers\n    self.headers = {key.lower(): value for key, value in headers.items()}\n    self.body = body\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.verify.Verifier.verify","title":"<code>verify(raise_on_fail=False)</code>","text":"<p>Verifies the digital signature of an HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>raise_on_fail</code> <code>bool</code> <p>Return error on failure. defaults to False.</p> <code>False</code> <p>Returns:</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature header is missing or if the algorithm is unsupported.</p> Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>def verify(self, raise_on_fail: bool = False) -&gt; Union[str, None]:\n    \"\"\"Verifies the digital signature of an HTTP request.\n\n    Args:\n        raise_on_fail (bool, optional): Return error on failure. defaults to False.\n\n    Returns:\n\n    Raises:\n        ValueError: If the signature header is missing or if the algorithm is unsupported.\n    \"\"\"\n    headers = self.headers.copy()\n\n    signature_header = headers.get(\"signature\")\n    if not signature_header:\n        if raise_on_fail:\n            raise MissingSignature(\n                \"Signature header is missing\"\n            )\n        return None\n\n    signature_parts = {}\n    for item in signature_header.split(\",\"):\n        key, value = item.split(\"=\", 1)\n        signature_parts[key.strip()] = value.strip().strip('\"')\n\n    signature = self.__decode_sign(signature_parts[\"signature\"])\n    key_id = signature_parts[\"keyId\"]\n    algorithm = signature_parts[\"algorithm\"]\n\n    if algorithm != \"rsa-sha256\":\n        if raise_on_fail:\n            raise UnknownSignature(\n                f\"Unsupported algorithm. Algorithm must be rsa-sha256, but passed {algorithm}.\"\n            )\n        return None\n\n    signed_headers = signature_parts[\"headers\"].split()\n\n    parsed_url = urlparse(self.url)\n\n    signature_headers = headers.copy()\n    signature_headers[\"(request-target)\"] = (\n        f\"{self.method.lower()} {parsed_url.path}\"\n    )\n    signature_string = build_string(\n        signature_headers, headers=signed_headers\n    ).encode(\"utf-8\")\n\n    public_key = serialization.load_pem_public_key(\n        self.public_pem.encode(\"utf-8\"), backend=default_backend()\n    )\n\n    try:\n        public_key.verify(\n            signature, signature_string, padding.PKCS1v15(), hashes.SHA256()\n        )\n    except InvalidSignature:\n        if raise_on_fail:\n            raise VerificationFailed(\n                \"Invalid signature\"\n            )\n        return None\n\n    expected_digest = calculate_digest(self.body)\n    if headers.get(\"digest\") != expected_digest:\n        if raise_on_fail:\n            raise VerificationFailed(\n                \"Digest mismatch\"\n            )\n        return None\n\n    date_header = headers.get(\"date\")\n    if date_header:\n        date = datetime.datetime.datetime.strptime(\n            date_header, \"%a, %d %b %Y %H:%M:%S GMT\"\n        )\n        gmt_tz = pytz.timezone('GMT')\n        gmt_time = gmt_tz.localize(date)\n        request_time = gmt_time.astimezone(pytz.utc)\n        current_time = datetime.utcnow()\n        if abs((current_time - request_time).total_seconds()) &gt; 3600:\n            if raise_on_fail:\n                raise VerificationFailed(\n                    \"Date header is too far from current time\"\n                )\n            return None\n\n    return key_id\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.verify.draftVerifier","title":"<code>draftVerifier</code>","text":"Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>class draftVerifier:\n    @staticmethod\n    @deprecated(\n        \"apsig.draft.verify.draftVerifier is deprecated; use apsig.draft.verify.Verifier instead. This will be removed in apsig 1.0.\"\n    )\n    def verify(\n        public_pem: str, method: str, url: str, headers: dict, body: bytes = b\"\"\n    ) -&gt; tuple[bool, str]:\n        \"\"\"Verifies the digital signature of an HTTP request.\n\n        Args:\n            public_pem (str): The public key in PEM format used to verify the signature.\n            method (str): The HTTP method (e.g., \"GET\", \"POST\").\n            url (str): The URL of the request.\n            headers (dict): A dictionary of HTTP headers, including the signature and other relevant information.\n            body (bytes, optional): The request body. Defaults to an empty byte string.\n\n        Returns:\n            tuple: A tuple containing:\n                - bool: True if the signature is valid, False otherwise.\n                - str: A message indicating the result of the verification.\n\n        Raises:\n            ValueError: If the signature header is missing or if the algorithm is unsupported.\n        \"\"\"\n        try:\n            result = Verifier(\n                public_pem=public_pem, method=method, url=url, headers=headers, body=body\n            ).verify(raise_on_fail=True)\n        except Exception as e:\n            return False, str(e)\n        if result:\n            return True, \"Signature is valid\"\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.draft.verify.draftVerifier.verify","title":"<code>verify(public_pem, method, url, headers, body=b'')</code>  <code>staticmethod</code>","text":"<p>Verifies the digital signature of an HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>public_pem</code> <code>str</code> <p>The public key in PEM format used to verify the signature.</p> required <code>method</code> <code>str</code> <p>The HTTP method (e.g., \"GET\", \"POST\").</p> required <code>url</code> <code>str</code> <p>The URL of the request.</p> required <code>headers</code> <code>dict</code> <p>A dictionary of HTTP headers, including the signature and other relevant information.</p> required <code>body</code> <code>bytes</code> <p>The request body. Defaults to an empty byte string.</p> <code>b''</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[bool, str]</code> <p>A tuple containing: - bool: True if the signature is valid, False otherwise. - str: A message indicating the result of the verification.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature header is missing or if the algorithm is unsupported.</p> Source code in <code>libs/apsig/src/apsig/draft/verify.py</code> <pre><code>@staticmethod\n@deprecated(\n    \"apsig.draft.verify.draftVerifier is deprecated; use apsig.draft.verify.Verifier instead. This will be removed in apsig 1.0.\"\n)\ndef verify(\n    public_pem: str, method: str, url: str, headers: dict, body: bytes = b\"\"\n) -&gt; tuple[bool, str]:\n    \"\"\"Verifies the digital signature of an HTTP request.\n\n    Args:\n        public_pem (str): The public key in PEM format used to verify the signature.\n        method (str): The HTTP method (e.g., \"GET\", \"POST\").\n        url (str): The URL of the request.\n        headers (dict): A dictionary of HTTP headers, including the signature and other relevant information.\n        body (bytes, optional): The request body. Defaults to an empty byte string.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if the signature is valid, False otherwise.\n            - str: A message indicating the result of the verification.\n\n    Raises:\n        ValueError: If the signature header is missing or if the algorithm is unsupported.\n    \"\"\"\n    try:\n        result = Verifier(\n            public_pem=public_pem, method=method, url=url, headers=headers, body=body\n        ).verify(raise_on_fail=True)\n    except Exception as e:\n        return False, str(e)\n    if result:\n        return True, \"Signature is valid\"\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.ld_signature","title":"<code>ld_signature</code>","text":""},{"location":"references/apsig/#apsig.src.apsig.ld_signature.LDSignature","title":"<code>LDSignature</code>","text":"<p>A class for signing and verifying Linked Data signatures using the RSA signature algorithm. </p> <p>Attributes:</p> Name Type Description <code>private_key</code> <code>RSAPrivateKey</code> <p>The RSA private key used for signing.</p> <code>public_key</code> <code>RSAPublicKey</code> <p>The corresponding RSA public key.</p> <p>Methods:</p> Name Description <code>sign</code> <p>dict, creator: str, private_key: rsa.RSAPrivateKey, options: dict = None, created: datetime.datetime = None) -&gt; dict: Signs the provided document using the specified RSA private key.</p> <code>verify</code> <p>dict, public_key: rsa.RSAPublicKey | str) -&gt; bool: Verifies the signature of the provided document against the given public key.</p> Source code in <code>libs/apsig/src/apsig/ld_signature.py</code> <pre><code>class LDSignature:\n    \"\"\"A class for signing and verifying Linked Data signatures using the RSA signature algorithm. \n\n    Attributes:\n        private_key (rsa.RSAPrivateKey): The RSA private key used for signing.\n        public_key (rsa.RSAPublicKey): The corresponding RSA public key.\n\n    Methods:\n        sign(doc: dict, creator: str, private_key: rsa.RSAPrivateKey, options: dict = None, created: datetime.datetime = None) -&gt; dict:\n            Signs the provided document using the specified RSA private key.\n\n        verify(doc: dict, public_key: rsa.RSAPublicKey | str) -&gt; bool:\n            Verifies the signature of the provided document against the given public key.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def __normalized_hash(self, data):\n        norm_form = jsonld.normalize(\n            data, {\"algorithm\": \"URDNA2015\", \"format\": \"application/n-quads\"}\n        )\n        digest = hashes.Hash(hashes.SHA256())\n        digest.update(norm_form.encode(\"utf8\"))\n        return digest.finalize().hex().encode(\"ascii\")\n\n    def sign(\n        self,\n        doc: dict,\n        creator: str,\n        private_key: rsa.RSAPrivateKey,\n        options: dict = None,\n        created: datetime.datetime = None,\n    ):\n        \"\"\"Signs the provided document using the specified RSA private key.\n\n        Args:\n            doc (dict): The document to be signed.\n            creator (str): The identifier of the creator of the document.\n            private_key (rsa.RSAPrivateKey): The RSA private key used for signing.\n            options (dict, optional): Additional signing options. Defaults to None.\n            created (datetime.datetime, optional): The timestamp when the signature is created. \n                Defaults to the current UTC time if not provided.\n\n        Returns:\n            dict: The signed document containing the original data and the signature.\n        \"\"\"\n        options: dict[str, str] = {\n            \"@context\": \"https://w3c-ccg.github.io/security-vocab/contexts/security-v1.jsonld\", # \"https://w3id.org/identity/v1\"\n            \"creator\": creator,\n            \"created\": created or utcnow().strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\",\n        }\n\n        to_be_signed = self.__normalized_hash(options) + self.__normalized_hash(doc)\n\n        signature = base64.b64encode(private_key.sign(\n            to_be_signed, padding.PKCS1v15(), hashes.SHA256()\n        ))\n\n        return {\n            **doc,\n            \"signature\": {\n                **options,\n                \"type\": \"RsaSignature2017\",\n                \"signatureValue\": signature.decode(\"ascii\"),\n            },\n        }\n\n    def verify(self, doc: dict, public_key: rsa.RSAPublicKey | str, raise_on_fail: bool = False) -&gt; Union[str, None]:\n        \"\"\"Verifies the signature of the provided document against the given public key.\n\n        Args:\n            doc (dict): The signed document to verify.\n            public_key (rsa.RSAPublicKey | str): The RSA public key in PEM format or as a multibase-encoded string.\n\n        Returns:\n            bool: True if the signature is valid; otherwise, an exception is raised.\n\n        Raises:\n            MissingSignature: If the signature section is missing in the document.\n            UnknownSignature: If the signature type is not recognized.\n            VerificationFailed: If the signature verification fails.\n        \"\"\"\n        if isinstance(public_key, str):\n            codec, data = multicodec.unwrap(multibase.decode(public_key))\n            if codec.name != \"rsa-pub\":\n                if raise_on_fail:\n                    raise ValueError(\"public_key must be RSA PublicKey.\")\n                return None\n            public_key = serialization.load_pem_public_key(data, backend=default_backend())\n        try:\n            document = doc.copy()\n            signature = document.pop(\"signature\")\n            options = {\n                \"@context\": \"https://w3c-ccg.github.io/security-vocab/contexts/security-v1.jsonld\",\n                \"creator\": signature[\"creator\"],\n                \"created\": signature[\"created\"],\n            }\n        except KeyError:\n            if raise_on_fail:\n                raise MissingSignature(\"Invalid signature section\")\n            return None\n        if signature[\"type\"].lower() != \"rsasignature2017\":\n            if raise_on_fail:\n                raise UnknownSignature(\"Unknown signature type\")\n            return None\n        final_hash = self.__normalized_hash(options) + self.__normalized_hash(document)\n        try:\n            public_key.verify(\n                base64.b64decode(signature[\"signatureValue\"]),\n                final_hash,\n                padding.PKCS1v15(),\n                hashes.SHA256(),\n            )\n            return signature[\"creator\"]\n        except InvalidSignature:\n            if raise_on_fail:\n                raise VerificationFailed(\"LDSignature mismatch\")\n            return None\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.ld_signature.LDSignature.sign","title":"<code>sign(doc, creator, private_key, options=None, created=None)</code>","text":"<p>Signs the provided document using the specified RSA private key.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>dict</code> <p>The document to be signed.</p> required <code>creator</code> <code>str</code> <p>The identifier of the creator of the document.</p> required <code>private_key</code> <code>RSAPrivateKey</code> <p>The RSA private key used for signing.</p> required <code>options</code> <code>dict</code> <p>Additional signing options. Defaults to None.</p> <code>None</code> <code>created</code> <code>datetime</code> <p>The timestamp when the signature is created.  Defaults to the current UTC time if not provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The signed document containing the original data and the signature.</p> Source code in <code>libs/apsig/src/apsig/ld_signature.py</code> <pre><code>def sign(\n    self,\n    doc: dict,\n    creator: str,\n    private_key: rsa.RSAPrivateKey,\n    options: dict = None,\n    created: datetime.datetime = None,\n):\n    \"\"\"Signs the provided document using the specified RSA private key.\n\n    Args:\n        doc (dict): The document to be signed.\n        creator (str): The identifier of the creator of the document.\n        private_key (rsa.RSAPrivateKey): The RSA private key used for signing.\n        options (dict, optional): Additional signing options. Defaults to None.\n        created (datetime.datetime, optional): The timestamp when the signature is created. \n            Defaults to the current UTC time if not provided.\n\n    Returns:\n        dict: The signed document containing the original data and the signature.\n    \"\"\"\n    options: dict[str, str] = {\n        \"@context\": \"https://w3c-ccg.github.io/security-vocab/contexts/security-v1.jsonld\", # \"https://w3id.org/identity/v1\"\n        \"creator\": creator,\n        \"created\": created or utcnow().strftime(\"%Y-%m-%dT%H:%M:%S.%f\")[:-3] + \"Z\",\n    }\n\n    to_be_signed = self.__normalized_hash(options) + self.__normalized_hash(doc)\n\n    signature = base64.b64encode(private_key.sign(\n        to_be_signed, padding.PKCS1v15(), hashes.SHA256()\n    ))\n\n    return {\n        **doc,\n        \"signature\": {\n            **options,\n            \"type\": \"RsaSignature2017\",\n            \"signatureValue\": signature.decode(\"ascii\"),\n        },\n    }\n</code></pre>"},{"location":"references/apsig/#apsig.src.apsig.ld_signature.LDSignature.verify","title":"<code>verify(doc, public_key, raise_on_fail=False)</code>","text":"<p>Verifies the signature of the provided document against the given public key.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>dict</code> <p>The signed document to verify.</p> required <code>public_key</code> <code>RSAPublicKey | str</code> <p>The RSA public key in PEM format or as a multibase-encoded string.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>Union[str, None]</code> <p>True if the signature is valid; otherwise, an exception is raised.</p> <p>Raises:</p> Type Description <code>MissingSignature</code> <p>If the signature section is missing in the document.</p> <code>UnknownSignature</code> <p>If the signature type is not recognized.</p> <code>VerificationFailed</code> <p>If the signature verification fails.</p> Source code in <code>libs/apsig/src/apsig/ld_signature.py</code> <pre><code>def verify(self, doc: dict, public_key: rsa.RSAPublicKey | str, raise_on_fail: bool = False) -&gt; Union[str, None]:\n    \"\"\"Verifies the signature of the provided document against the given public key.\n\n    Args:\n        doc (dict): The signed document to verify.\n        public_key (rsa.RSAPublicKey | str): The RSA public key in PEM format or as a multibase-encoded string.\n\n    Returns:\n        bool: True if the signature is valid; otherwise, an exception is raised.\n\n    Raises:\n        MissingSignature: If the signature section is missing in the document.\n        UnknownSignature: If the signature type is not recognized.\n        VerificationFailed: If the signature verification fails.\n    \"\"\"\n    if isinstance(public_key, str):\n        codec, data = multicodec.unwrap(multibase.decode(public_key))\n        if codec.name != \"rsa-pub\":\n            if raise_on_fail:\n                raise ValueError(\"public_key must be RSA PublicKey.\")\n            return None\n        public_key = serialization.load_pem_public_key(data, backend=default_backend())\n    try:\n        document = doc.copy()\n        signature = document.pop(\"signature\")\n        options = {\n            \"@context\": \"https://w3c-ccg.github.io/security-vocab/contexts/security-v1.jsonld\",\n            \"creator\": signature[\"creator\"],\n            \"created\": signature[\"created\"],\n        }\n    except KeyError:\n        if raise_on_fail:\n            raise MissingSignature(\"Invalid signature section\")\n        return None\n    if signature[\"type\"].lower() != \"rsasignature2017\":\n        if raise_on_fail:\n            raise UnknownSignature(\"Unknown signature type\")\n        return None\n    final_hash = self.__normalized_hash(options) + self.__normalized_hash(document)\n    try:\n        public_key.verify(\n            base64.b64decode(signature[\"signatureValue\"]),\n            final_hash,\n            padding.PKCS1v15(),\n            hashes.SHA256(),\n        )\n        return signature[\"creator\"]\n    except InvalidSignature:\n        if raise_on_fail:\n            raise VerificationFailed(\"LDSignature mismatch\")\n        return None\n</code></pre>"}]}